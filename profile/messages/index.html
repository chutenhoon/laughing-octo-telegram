<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title data-i18n-key="profile.messages.pageTitle">Messages | polyflux.xyz</title>
    <link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png" />
    <link rel="icon" type="image/png" sizes="192x192" href="../../android-chrome-192x192.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="../../android-chrome-512x512.png" />
    <link rel="manifest" href="../../site.webmanifest" />
    <link rel="icon" href="../../favicon.ico" />
    <meta name="description" content="S&#224;n th&#432;&#417;ng m&#7841;i &#273;i&#7879;n t&#7917; uy t&#237;n, giao nhanh, b&#7843;o h&#224;nh r&#245; r&#224;ng, h&#7895; tr&#7907; 24/7." />
    <meta property="og:title" content="polyflux.xyz" />
    <meta property="og:description" content="S&#224;n th&#432;&#417;ng m&#7841;i &#273;i&#7879;n t&#7917; uy t&#237;n, giao nhanh, b&#7843;o h&#224;nh r&#245; r&#224;ng, h&#7895; tr&#7907; 24/7." />
    <meta property="og:image" content="../../asset/logo-preview.png" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="vi_VN" />
    <meta property="og:site_name" content="polyflux.xyz" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="polyflux.xyz" />
    <meta name="twitter:description" content="S&#224;n th&#432;&#417;ng m&#7841;i &#273;i&#7879;n t&#7917; uy t&#237;n, giao nhanh, b&#7843;o h&#224;nh r&#245; r&#224;ng, h&#7895; tr&#7907; 24/7." />
    <meta name="twitter:image" content="../../asset/logo-preview.png" />
<link rel="stylesheet" href="../../asset/base.css" />
  </head>
  <body class="page-profile chat-page">
    <video class="video-bg" autoplay muted loop playsinline preload="metadata">
      <source src="../../asset/bg-donut.mp4" type="video/mp4" />
    </video>
    <div class="video-overlay"></div>

    <header class="wrap">
      <nav class="nav glass">
        <a href="/" class="brand" style="display: flex; align-items: center; gap: 12px; text-decoration: none;">
          <img src="../../asset/logo.png" alt="PolyFlux" />
          <span>polyflux<b>.xyz</b></span>
        </a>
        <div class="nav-links">
          <a href="/sanpham/" data-nav="sanpham">S&#7843;n Ph&#7849;m <span class="badge">HOT</span></a>
          <a href="/dichvu/" data-nav="dichvu">D&#7883;ch V&#7909;</a>
          <a href="/nhiemvu/" data-nav="nhiemvu">Nhi&#7879;m V&#7909;</a>
          <a href="/profile/topups/" data-nav="topups">N&#7841;p ti&#7873;n</a>
        </div>
        <div class="nav-actions">
                    <button class="btn balance-btn" data-balance type="button">0 VND</button>
          <a class="btn login-btn" href="/login/">Login</a>
        </div>
      </nav>
    </header>

    <main class="wrap">
      <section class="section message-section">
        <div class="card message-shell is-empty" id="message-shell">
          <aside class="message-sidebar">
            <div class="message-sidebar-head">
              <h3 data-i18n-key="profile.messages.inboxTitle">Inbox</h3>
              <span class="message-sidebar-count" data-i18n-key="profile.messages.inboxCount">1 conversation</span>
            </div>
            <div class="message-search">
              <input id="message-search-input" type="text" placeholder="Search..." data-i18n-placeholder="profile.messages.searchPlaceholder" />
              <button class="message-search-clear" id="message-search-clear" type="button" aria-label="Clear">x</button>
            </div>
            <div class="message-thread-skeleton" id="inbox-skeleton" aria-hidden="true">
              <div class="message-thread-skeleton-row">
                <span class="message-thread-skeleton-avatar skeleton"></span>
                <div class="message-thread-skeleton-lines">
                  <span class="message-thread-skeleton-line skeleton w-60"></span>
                  <span class="message-thread-skeleton-line skeleton w-45"></span>
                </div>
              </div>
              <div class="message-thread-skeleton-row">
                <span class="message-thread-skeleton-avatar skeleton"></span>
                <div class="message-thread-skeleton-lines">
                  <span class="message-thread-skeleton-line skeleton w-60"></span>
                  <span class="message-thread-skeleton-line skeleton w-45"></span>
                </div>
              </div>
              <div class="message-thread-skeleton-row">
                <span class="message-thread-skeleton-avatar skeleton"></span>
                <div class="message-thread-skeleton-lines">
                  <span class="message-thread-skeleton-line skeleton w-60"></span>
                  <span class="message-thread-skeleton-line skeleton w-45"></span>
                </div>
              </div>
              <div class="message-thread-skeleton-row">
                <span class="message-thread-skeleton-avatar skeleton"></span>
                <div class="message-thread-skeleton-lines">
                  <span class="message-thread-skeleton-line skeleton w-60"></span>
                  <span class="message-thread-skeleton-line skeleton w-45"></span>
                </div>
              </div>
              <div class="message-thread-skeleton-row">
                <span class="message-thread-skeleton-avatar skeleton"></span>
                <div class="message-thread-skeleton-lines">
                  <span class="message-thread-skeleton-line skeleton w-60"></span>
                  <span class="message-thread-skeleton-line skeleton w-45"></span>
                </div>
              </div>
              <div class="message-thread-skeleton-row">
                <span class="message-thread-skeleton-avatar skeleton"></span>
                <div class="message-thread-skeleton-lines">
                  <span class="message-thread-skeleton-line skeleton w-60"></span>
                  <span class="message-thread-skeleton-line skeleton w-45"></span>
                </div>
              </div>
            </div>
            <div class="message-thread-list" id="inbox-list">
              <button class="message-thread" type="button" data-thread="admin">
                <div class="message-avatar">
                  <img src="../../assets/avt-admin.png" alt="BK" data-support-avatar />
                </div>
                <div class="message-thread-info">
                  <div class="message-thread-top">
                    <span class="message-thread-name" data-i18n-key="profile.messages.thread.name" data-support-name>Bach Kim</span>
                    <span class="message-thread-time">--</span>
                  </div>
                  <div class="message-thread-bottom">
                    <span class="message-thread-note" data-support-status data-i18n-key="profile.messages.thread.note">Official support</span>
                    <span class="message-role admin" data-i18n-key="profile.messages.role.admin">Admin</span>
                  </div>
                </div>
              </button>
            </div>
            <div class="message-sidebar-foot" data-i18n-key="profile.messages.thread.empty" style="display: none;">No other conversations.</div>
          </aside>

          <section class="message-panel">
            <div class="message-header">
              <div class="message-header-left">
                <button class="message-back" id="message-back" type="button" aria-label="Back" data-i18n-aria="profile.messages.back">
                  <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M15 6l-6 6 6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                  </svg>
                </button>
                <div class="message-user">
                  <div class="message-avatar large">
                    <img src="../../assets/avt-admin.png" alt="BK" data-support-avatar />
                  </div>
                  <div>
                    <div class="message-user-name" data-i18n-key="profile.messages.thread.name" data-support-name>Bach Kim</div>
                    <div class="message-user-sub" data-support-status data-i18n-key="profile.messages.user.sub">Admin support</div>
                  </div>
                </div>
              </div>
              <span class="message-role admin" data-i18n-key="profile.messages.role.admin">Admin</span>
            </div>
            <div class="message-empty" id="message-empty" aria-hidden="true">
              <div class="message-empty-card">
                <div class="message-empty-icon" aria-hidden="true">
                  <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true">
                    <path
                      d="M7 18l-3 3v-4a7 7 0 01-1-3.6C3 7.4 7 4 12 4s9 3.4 9 7.4-4 7.6-9 7.6c-1.7 0-3.3-.3-4.7-.9"
                      stroke="currentColor"
                      stroke-width="1.6"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      fill="none"
                    />
                  </svg>
                </div>
                <strong class="message-empty-title">Ch&#7885;n m&#7897;t cu&#7897;c tr&#242; chuy&#7879;n &#273;&#7875; b&#7855;t &#273;&#7847;u</strong>
                <span class="message-empty-sub">Ch&#7885;n &#7903; danh s&#225;ch b&#234;n tr&#225;i &#273;&#7875; xem tin nh&#7855;n.</span>
              </div>
            </div>
            <div class="message-body" id="message-body">
              <div class="message-loading" id="message-loading" aria-hidden="true">
                <div class="message-skeleton-row">
                  <span class="message-skeleton-avatar skeleton"></span>
                  <span class="message-skeleton-bubble skeleton w-60"></span>
                </div>
                <div class="message-skeleton-row outgoing">
                  <span class="message-skeleton-bubble skeleton w-45"></span>
                </div>
                <div class="message-skeleton-row">
                  <span class="message-skeleton-avatar skeleton"></span>
                  <span class="message-skeleton-bubble skeleton w-70"></span>
                </div>
              </div>
              <div class="empty-state" style="margin-top: 10px; display: none;">
                <strong data-i18n-key="empty.noData">Ch&#432;a c&#243; d&#7919; li&#7879;u</strong>
              </div>
            </div>
            <button class="message-new" id="message-new" type="button">Tin má»›i</button>
            <div class="message-input">
              <div class="emoji-panel" id="emoji-panel">
                <button type="button" data-emoji="&#128512;">&#128512;</button>
                <button type="button" data-emoji="&#128516;">&#128516;</button>
                <button type="button" data-emoji="&#128514;">&#128514;</button>
                <button type="button" data-emoji="&#128525;">&#128525;</button>
                <button type="button" data-emoji="&#128557;">&#128557;</button>
                <button type="button" data-emoji="&#128526;">&#128526;</button>
                <button type="button" data-emoji="&#128077;">&#128077;</button>
                <button type="button" data-emoji="&#127881;">&#127881;</button>
              </div>
              <div class="quick-replies" id="quick-replies" role="listbox" aria-hidden="true"></div>
              <button
                class="btn ghost message-icon"
                id="message-emoji"
                type="button"
                aria-label="Emoji"
                data-i18n-aria="profile.messages.emojiLabel"
              >
                <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
                  <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="1.6" fill="none" />
                  <path d="M8.5 10.5h.01M15.5 10.5h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
                  <path d="M8.5 14.5c1 1 2.3 1.5 3.5 1.5s2.5-.5 3.5-1.5" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" fill="none" />
                </svg>
              </button>
              <button
                class="btn ghost message-icon"
                id="message-attach"
                type="button"
                aria-label="Attachment"
                data-i18n-aria="profile.messages.attachLabel"
              >
                <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
                  <path
                    d="M9 12.5l5.6-5.6a3 3 0 114.2 4.2l-6.8 6.8a5 5 0 11-7.1-7.1l6.5-6.5"
                    stroke="currentColor"
                    stroke-width="1.6"
                    fill="none"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>
              <input
                id="message-input"
                type="text"
                placeholder="Type a message..."
                data-i18n-placeholder="profile.messages.inputPlaceholder"
              />
              <button class="btn primary message-send" id="message-send" type="button" data-i18n-key="profile.messages.send">Send</button>
              <input id="message-file" type="file" accept="image/*" style="display: none;" />
            </div>
          </section>
        </div>
      </section>

      <div class="modal-backdrop chat-preview-modal" id="chat-preview-modal" aria-hidden="true">
        <div class="modal-card chat-preview-card" role="dialog" aria-modal="true" aria-labelledby="chat-preview-title">
          <div class="chat-preview-head">
            <h3 id="chat-preview-title">Xem truoc anh</h3>
            <button class="btn ghost chat-preview-close" id="chat-preview-close" type="button" aria-label="Close">
              <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M6 6l12 12M18 6l-12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
              </svg>
            </button>
          </div>
          <div class="chat-preview-body">
            <div class="chat-preview-media">
              <img id="chat-preview-image" alt="Preview" />
            </div>
            <div class="chat-preview-meta">
              <span id="chat-preview-size">--</span>
            </div>
          </div>
          <div class="modal-actions">
            <button class="btn ghost" id="chat-preview-cancel" type="button">Huy</button>
            <button class="btn primary chat-preview-send" id="chat-preview-send" type="button">Gui</button>
          </div>
        </div>
      </div>

      <footer>
        <div class="footer-grid">
          <div>
            <h4>About polyflux.xyz</h4>
            <p>
              The #1 trusted marketplace for digital assets on polyflux.xyz. Buy accounts, emails, tools and more with
              instant delivery.
            </p>
          </div>
          <div>
            <h4>&#272;i&#7873;u h&#432;&#7899;ng</h4>
            <p><a href="/sanpham/">S&#7843;n ph&#7849;m</a></p>
            <p><a href="/dichvu/">D&#7883;ch v&#7909;</a></p>
            <p><a href="/nhiemvu/">Nhi&#7879;m v&#7909; marketplace</a></p>
            <p><a href="/profile/">T&#224;i kho&#7843;n c&#7911;a t&#244;i</a></p>
          </div>
          <div>
            <h4>Thanh to&#225;n &amp; b&#7843;o m&#7853;t</h4>
            <p>20+ ph&#432;&#417;ng th&#7913;c thanh to&#225;n, x&#7917; l&#253; t&#7921; &#273;&#7897;ng.</p>
            <p>L&#7883;ch s&#7917; &#273;&#417;n h&#224;ng minh b&#7841;ch.</p>
            <p>2FA &amp; c&#7843;nh b&#225;o &#273;&#259;ng nh&#7853;p kh&#7843; nghi.</p>
          </div>
          <div>
            <h4>Tham gia b&#225;n h&#224;ng</h4>
            <p>Mu&#7889;n m&#7903; gian h&#224;ng tr&#234;n polyflux.xyz?</p>
            <a href="/seller/join/" class="btn primary" style="margin-top: 8px; display: inline-flex; align-items: center; gap: 6px;">
              Tham gia b&#225;n h&#224;ng
            </a>
          </div>
        </div>
      </footer>
    </main>

    <nav class="mobile-nav">
      <div class="mobile-nav-top">
        <a href="/" class="mobile-brand" style="display: flex; align-items: center; gap: 10px; text-decoration: none;">
          <img src="../../asset/logo.png" alt="PolyFlux" />
          <span>polyflux<b>.xyz</b></span>
        </a>
        <div class="mobile-actions">
                    <button class="btn balance-btn" data-balance type="button">0 VND</button>
          <a class="btn login-btn" href="/login/">Login</a>
        
          <button class="menu-btn" id="mobile-menu" type="button" aria-label="Menu">
            <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M4 6h16M4 12h16M4 18h16" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
            </svg>
          </button>
        </div>
      </div>
      <div class="mobile-links">
        <a href="/sanpham/" data-nav="sanpham">S&#7843;n Ph&#7849;m</a>
        <a href="/dichvu/" data-nav="dichvu">D&#7883;ch V&#7909;</a>
        <a href="/nhiemvu/" data-nav="nhiemvu">Nhi&#7879;m V&#7909;</a>
        <a href="/profile/topups/" data-nav="topups">N&#7841;p ti&#7873;n</a>
      </div>
    </nav>

    <div id="chat-dropzone-portal" aria-hidden="true"></div>

    <script src="../../asset/render.js"></script>
    <script>
      const initMessagesPage = () => {
        if (window.__profileMessagesInit) return;
        window.__profileMessagesInit = true;
        try {
        const messageShell = document.getElementById("message-shell");
        const messageBack = document.getElementById("message-back");
        const isNarrow = () => window.matchMedia("(max-width: 820px)").matches;
        const uiKit = window.BKUI || {};
        const applyNameWithBadge = typeof uiKit.applyNameWithBadge === "function" ? uiKit.applyNameWithBadge : null;
        const renderNameWithBadge = typeof uiKit.renderNameWithBadge === "function" ? uiKit.renderNameWithBadge : null;
        const setDetailView = (show) => {
          if (!messageShell) return;
          if (!isNarrow()) {
            messageShell.classList.remove("is-detail");
            return;
          }
          messageShell.classList.toggle("is-detail", show);
        };

        if (messageShell && isNarrow()) {
          messageShell.classList.remove("is-detail");
        }

        if (messageBack) {
          messageBack.addEventListener("click", () => setDetailView(false));
        }

        window.addEventListener("resize", () => setDetailView(messageShell && messageShell.classList.contains("is-detail")));

        const messageBody = document.getElementById("message-body");
        const messageEmpty = document.getElementById("message-empty");
        const messageInput = document.getElementById("message-input");
        const sendBtn = document.getElementById("message-send");
        const emojiBtn = document.getElementById("message-emoji");
        const emojiPanel = document.getElementById("emoji-panel");
        const attachBtn = document.getElementById("message-attach");
        const fileInput = document.getElementById("message-file");
        const messageNewBtn = document.getElementById("message-new");
        const searchInput = document.getElementById("message-search-input");
        const searchClear = document.getElementById("message-search-clear");
        const messageLoading = document.getElementById("message-loading");
        const quickRepliesEl = document.getElementById("quick-replies");
        const previewModal = document.getElementById("chat-preview-modal");
        const previewImage = document.getElementById("chat-preview-image");
        const previewSize = document.getElementById("chat-preview-size");
        const previewSend = document.getElementById("chat-preview-send");
        const previewCancel = document.getElementById("chat-preview-cancel");
        const previewClose = document.getElementById("chat-preview-close");

        const normalizeUserId = (value) => {
          if (value == null) return "";
          const raw = String(value).trim();
          if (!raw) return "";
          if (/^\d+(\.0+)?$/.test(raw)) return String(Number(raw));
          return raw;
        };

        const isFile = window.location.protocol === "file:";
        const root =
          typeof getRootPath === "function"
            ? getRootPath()
            : typeof getProjectRoot === "function"
              ? getProjectRoot()
              : "/";
        const auth = window.BKAuth && typeof window.BKAuth.read === "function" ? window.BKAuth.read() : { loggedIn: false };
        const user = auth && auth.user ? auth.user : {};
        const role = typeof user.role === "string" ? user.role.trim().toLowerCase() : "";
        const isAdminUser = role === "admin" || String(user.username || "").trim().toLowerCase() === "admin";
        const rawUserId = normalizeUserId(user.id || user.username || user.name || "");
        const apiUrl = "/api/messages";
        const conversationsUrl = "/api/conversations";
        const uploadUrl = "/api/messages/upload";
        const heartbeatUrl = "/api/chat/heartbeat";
        const pingUrl = "/api/ping";
        let resolvedUserId = rawUserId ? String(rawUserId) : "";

        const notify = (message) => {
          if (!message) return;
          if (window.BKAuth && typeof window.BKAuth.showToast === "function") {
            window.BKAuth.showToast(message);
          } else {
            alert(message);
          }
        };
        const buildAuthHeaders = () => {
          const headers = {};
          if (user && user.id != null && String(user.id).trim()) headers["x-user-id"] = String(user.id).trim();
          if (user && user.username) headers["x-user-username"] = String(user.username);
          if (user && user.email) headers["x-user-email"] = String(user.email);
          if (user && user.name) headers["x-user-name"] = String(user.name);
          if (user && (user.avatar_url || user.avatar)) headers["x-user-avatar"] = String(user.avatar_url || user.avatar);
          if (user && user.role) headers["x-user-role"] = String(user.role);
          return headers;
        };
        const getLanguage = () => (typeof getCurrentLanguage === "function" ? getCurrentLanguage() : "vi");
        const t = (key, fallback) =>
          typeof formatI18n === "function" ? formatI18n(getLanguage(), key, fallback) : fallback || key;
        const queryParams = new URLSearchParams(window.location.search);
        const decodeParam = (value) => {
          const raw = String(value || "");
          if (!raw) return "";
          try {
            return decodeURIComponent(raw);
          } catch (error) {
            return raw;
          }
        };
        const queryConversationId = decodeParam(
          queryParams.get("conversationId") || queryParams.get("conversation_id") || ""
        ).trim();
        const getCanonicalChatUrl = () => {
          if (isFile) {
            const url = new URL(window.location.href);
            url.search = "";
            url.hash = "";
            return url.toString();
          }
          return "/profile/messages";
        };
        const readHistoryConversationId = () => {
          const state = window.history && window.history.state ? window.history.state : null;
          return state && state.conversationId ? String(state.conversationId) : "";
        };
        const historyConversationId = readHistoryConversationId();
        let initialConversationId = historyConversationId || queryConversationId;
        const setHistoryState = (conversationId, options = {}) => {
          if (!window.history) return;
          const nextId = conversationId ? String(conversationId) : "";
          const mode = options.mode === "push" ? "pushState" : "replaceState";
          if (typeof window.history[mode] !== "function") return;
          const current = readHistoryConversationId();
          if (mode === "pushState" && nextId && nextId === current) return;
          const url = getCanonicalChatUrl();
          const state = nextId ? { conversationId: nextId } : {};
          window.history[mode](state, "", url);
        };
        const buildProfileUrl = (profile) => {
          const username = profile && profile.username ? String(profile.username).trim() : "";
          const userId = profile && (profile.id || profile.userId) ? String(profile.id || profile.userId).trim() : "";
          if (username) {
            const base = root + (isFile ? "profile/public/index.html" : "u/");
            return isFile ? `${base}?u=${encodeURIComponent(username)}` : `${base}${encodeURIComponent(username)}`;
          }
          const fallbackBase = root + (isFile ? "profile/public/index.html" : "profile/public/");
          return userId ? `${fallbackBase}?id=${encodeURIComponent(userId)}` : fallbackBase;
        };
        const openProfile = (profile) => {
          const url = buildProfileUrl(profile);
          if (!url) return;
          window.location.href = url;
        };
        const queryUsername = decodeParam(queryParams.get("u") || queryParams.get("username") || "").trim();
        const queryUserId = normalizeUserId(
          decodeParam(queryParams.get("uid") || queryParams.get("id") || queryParams.get("userId") || queryParams.get("user_id") || "")
        );
        const prefillTarget = { userId: queryUserId, username: queryUsername };
        const directTarget = { userId: queryUserId, username: queryUsername };
        if (!directTarget.userId && queryConversationId && isDirectConversationId(queryConversationId)) {
          const parsed = parseDirectConversationId(queryConversationId);
          if (parsed) {
            const selfId = normalizeUserId(rawUserId);
            if (selfId && String(parsed.userA) === String(selfId)) {
              directTarget.userId = parsed.userB;
            } else if (selfId && String(parsed.userB) === String(selfId)) {
              directTarget.userId = parsed.userA;
            }
          }
        }
        let directProfile = null;
        let directFailed = false;
        let directConversation = null;
        let prefillProfile = null;
        let prefillFailed = false;
        let prefillApplied = false;
        let directApplied = false;
        let requestedApplied = false;

        const fetchPrefillProfile = async () => {
          if (!isAdminUser) return null;
          if (isFile) return null;
          if (prefillProfile || prefillFailed) return prefillProfile;
          const params = new URLSearchParams();
          if (prefillTarget.username) {
            params.set("u", prefillTarget.username);
          } else if (prefillTarget.userId) {
            params.set("id", prefillTarget.userId);
          } else {
            prefillFailed = true;
            return null;
          }
          params.set("view", "chat");
          try {
            const response = await fetch(`/api/profile?${params.toString()}`);
            const data = await response.json().catch(() => null);
            if (!response.ok || !data || !data.user) {
              prefillFailed = true;
              return null;
            }
            prefillProfile = data.user;
            if (!prefillTarget.userId) {
              const resolvedId = normalizeUserId(data.user.id || data.user.userId || data.user.username || "");
              if (resolvedId) prefillTarget.userId = resolvedId;
            }
            return prefillProfile;
          } catch (error) {
            prefillFailed = true;
            return null;
          }
        };
        const MAX_IMAGE_SIZE = 2 * 1024 * 1024;
        const DIRECT_CONVERSATION_PREFIX = "dm:";
        const isDirectConversationId = (value) => String(value || "").startsWith(DIRECT_CONVERSATION_PREFIX);
        const parseDirectConversationId = (value) => {
          const raw = String(value || "");
          if (!raw.startsWith(DIRECT_CONVERSATION_PREFIX)) return null;
          const body = raw.slice(DIRECT_CONVERSATION_PREFIX.length);
          const parts = body.split(":");
          if (parts.length !== 2) return null;
          const userA = normalizeUserId(parts[0]);
          const userB = normalizeUserId(parts[1]);
          if (!userA || !userB) return null;
          return { userA, userB };
        };
        const hasDirectTarget = () => Boolean(directTarget.userId || directTarget.username);
        const compareIds = (left, right) => {
          const a = String(left || "");
          const b = String(right || "");
          if (/^\d+$/.test(a) && /^\d+$/.test(b)) {
            return Number(a) - Number(b);
          }
          return a.localeCompare(b);
        };
        const buildDirectConversationId = (left, right) => {
          const a = normalizeUserId(left);
          const b = normalizeUserId(right);
          if (!a || !b) return "";
          return compareIds(a, b) <= 0 ? `${DIRECT_CONVERSATION_PREFIX}${a}:${b}` : `${DIRECT_CONVERSATION_PREFIX}${b}:${a}`;
        };
        const threadList = document.getElementById("inbox-list") || document.querySelector(".message-thread-list");
        const inboxSkeleton = document.getElementById("inbox-skeleton");
        const sidebarCount = document.querySelector(".message-sidebar-count");
        const sidebarFoot = document.querySelector(".message-sidebar-foot");
        const searchWrap = document.querySelector(".message-search");
        const inputWrap = document.querySelector(".message-input");
        const headerRoleBadge = document.querySelector(".message-header .message-role");
        const rootStyle = document.documentElement.style;
        let composerResizeObserver = null;
        let viewportResizeTick = 0;
        let composerResizeTick = 0;

        const setComposerHeight = () => {
          if (!inputWrap) return;
          const height = Math.ceil(inputWrap.getBoundingClientRect().height);
          if (!height) return;
          rootStyle.setProperty("--composer-h", `${height}px`);
        };

        const setViewportHeight = () => {
          const height = window.visualViewport ? Math.round(window.visualViewport.height) : window.innerHeight;
          if (!height) return;
          rootStyle.setProperty("--vvh", `${height}px`);
        };

        const scheduleViewportHeight = () => {
          if (viewportResizeTick) return;
          viewportResizeTick = requestAnimationFrame(() => {
            viewportResizeTick = 0;
            setViewportHeight();
          });
        };

        const scheduleComposerHeight = () => {
          if (composerResizeTick) return;
          composerResizeTick = requestAnimationFrame(() => {
            composerResizeTick = 0;
            setComposerHeight();
          });
        };

        const initChatLayoutSizing = () => {
          setComposerHeight();
          setViewportHeight();
          if (inputWrap && typeof ResizeObserver !== "undefined" && !composerResizeObserver) {
            composerResizeObserver = new ResizeObserver(() => {
              scheduleComposerHeight();
            });
            composerResizeObserver.observe(inputWrap);
          }
          const handleViewportChange = () => {
            scheduleComposerHeight();
            scheduleViewportHeight();
          };
          window.addEventListener("resize", handleViewportChange, { passive: true });
          window.addEventListener("orientationchange", handleViewportChange, { passive: true });
          if (window.visualViewport) {
            window.visualViewport.addEventListener("resize", handleViewportChange, { passive: true });
            window.visualViewport.addEventListener("scroll", handleViewportChange, { passive: true });
          }
        };
        const headerName = document.querySelector(".message-user-name");
        const adminAvatar =
          window.BKAssets && typeof window.BKAssets.getAdminAvatarUrl === "function"
            ? window.BKAssets.getAdminAvatarUrl()
            : typeof getAvatarUrl === "function"
              ? getAvatarUrl({ role: "admin", username: "admin", is_admin: true })
              : "/assets/avt-admin.png";
        let selfUserId = rawUserId ? String(rawUserId) : "";
        let supportAvatar = adminAvatar;
        let supportUserId = "";
        let supportUsername = "admin";
        let activeUserId = "";
        let activeConversationId = "";
        let activeProfile = null;
        let currentConversationKey = "";
        let adminId = "";
        let messageTimer = null;
        let messageFetchController = null;
        let conversationList = [];
        let conversationListKey = "";
        const PAGE_SIZE = 20;
        const MESSAGE_POLL_ACTIVE_MS = 2000;
        const MESSAGE_POLL_HIDDEN_MS = 7000;
        const MESSAGE_POLL_BOOST_MS = 2000;
        const MESSAGE_BOOST_WINDOW_MS = 8000;
        const CHAT_POLL_ACTIVE_MS = 10000;
        const CHAT_POLL_HIDDEN_MS = 30000;
        const PING_ACTIVE_MS = 25000;
        const PING_HIDDEN_MS = 60000;
        const MESSAGE_CACHE_TTL_MS = 60000;
        const LIST_CACHE_TTL_MS = 30000;
        const IDLE_POLL_THRESHOLD_MS = 60000;
        const SEND_TIMEOUT_MS = 8000;
        const SEND_DEBOUNCE_MS = 350;
        const allowEmptyLabels = false;
        const messageMap = new Map();
        const messageNodes = new Map();
        const pendingMessages = new Map();
        let messageList = [];
        let renderedStart = 0;
        let renderedIds = new Set();
        let newMessageCount = 0;
        let lastMessageCursor = "";
        let oldestMessageCursor = "";
        let hasMoreMessages = false;
        let isLoadingOlderMessages = false;
        let boostUntil = 0;
        let messageRequestToken = 0;
        let listRequestToken = 0;
        let isLoadingList = false;
        let isLoadingMessages = false;
        let isChatLoadingConversations = false;
        let isChatLoadingMessages = false;
        let isChatOverlayLoading = true;
        let pollEnabled = false;
        let pollStartScheduled = false;
        let shouldAutoStartPolling = false;
        let loadMoreWrap = null;
        let loadMoreBtn = null;
        let messageListWrap = null;
        let emptyState = null;
        let messageResizeObserver = null;
        let messageResizeTick = 0;
        let isPollingMessages = false;
        let hasLoadedConversationList = false;
        let hasLoadedMessages = false;
        let isLoadingHeartbeat = false;
        let heartbeatEtag = "";
        let lastHeartbeatPayload = null;
        let conversationVersion = "";
        let conversationListEtag = "";
        let pingTimer = null;
        let lastPingAt = 0;
        let isPinging = false;
        const inflightRequests = new Map();
        const buildInflightKey = (url, options = {}) => {
          const method = String((options && options.method) || "GET").toUpperCase();
          return `${method}:${url}`;
        };
        const fetchDedup = (url, options = {}) => {
          const method = String((options && options.method) || "GET").toUpperCase();
          if (method !== "GET") return fetch(url, options);
          const key = buildInflightKey(url, options);
          if (inflightRequests.has(key)) return inflightRequests.get(key);
          const request = fetch(url, options).finally(() => inflightRequests.delete(key));
          inflightRequests.set(key, request);
          return request;
        };
        const sendControllers = new Map();
        const abortSendRequest = (clientId, reason) => {
          const key = String(clientId || "");
          if (!key) return;
          const inflight = sendControllers.get(key);
          if (!inflight) return;
          inflight.reason = reason || "duplicate";
          if (inflight.timeoutId) clearTimeout(inflight.timeoutId);
          try {
            inflight.controller.abort();
          } catch (error) {}
        };
        const resolveSendMeta = (data) => {
          const message = data && data.message ? data.message : null;
          const rawMessageId = data && (data.messageId != null ? data.messageId : data.message_id);
          const rawCreatedAt = data && (data.createdAt != null ? data.createdAt : data.created_at);
          const rawServerTime = data && (data.serverTime != null ? data.serverTime : data.server_time);
          const messageId = message && message.id != null ? String(message.id) : String(rawMessageId || "");
          const createdAt = message && message.createdAt ? message.createdAt : String(rawCreatedAt || "");
          const serverTime = rawServerTime != null ? String(rawServerTime) : "";
          return { message, messageId, createdAt, serverTime };
        };
        const sendMessageRequest = async (payload, clientId) => {
          const key = String(clientId || "");
          if (key) {
            abortSendRequest(key, "duplicate");
          }
          const controller = new AbortController();
          const inflight = { controller, timeoutId: null, reason: "" };
          inflight.timeoutId = setTimeout(() => {
            inflight.reason = "timeout";
            try {
              controller.abort();
            } catch (error) {}
          }, SEND_TIMEOUT_MS);
          if (key) {
            sendControllers.set(key, inflight);
          }
          try {
            const response = await fetch(apiUrl, {
              method: "POST",
              headers: { "content-type": "application/json" },
              body: JSON.stringify(payload),
              cache: "no-store",
              signal: controller.signal,
            });
            const data = await response.json().catch(() => null);
            return { response, data };
          } catch (error) {
            if (error && error.name === "AbortError") {
              return { aborted: true, reason: inflight.reason || "abort" };
            }
            throw error;
          } finally {
            if (key && sendControllers.get(key) === inflight) {
              sendControllers.delete(key);
            }
            if (inflight.timeoutId) clearTimeout(inflight.timeoutId);
          }
        };
        const abortMessageFetch = () => {
          if (!messageFetchController) return;
          try {
            messageFetchController.abort();
          } catch (error) {}
          messageFetchController = null;
          isLoadingMessages = false;
        };
        let unreadCount = 0;
        let lastHeartbeatAt = 0;
        let pendingPreviewFile = null;
        let pendingPreviewUrl = "";
        let pendingPreviewClientId = "";
        let isPreviewOpen = false;
        let isPreviewSending = false;
        let isComposerLocked = false;
        let isSendDebounceActive = false;
        let sendDebounceTimer = null;
        let lastStatusKey = "";
        let isSendingImage = false;
        let searchValue = "";
        let searchTimer = null;
        let lastActiveAt = Date.now();
        const conversationCache = { key: "", list: null, savedAt: 0 };
        const messageCache = new Map();
        const LIST_STORAGE_PREFIX = "bk_chat_list_cache_v1";
        const ACTIVE_STORAGE_PREFIX = "bk_chat_active_v1";
        if (messageBody) {
          emptyState = messageBody.querySelector(".empty-state");
        }
        const setConversationEmptyState = (isEmpty) => {
          if (messageShell) {
            messageShell.classList.toggle("is-empty", isEmpty);
          }
          if (messageEmpty) {
            messageEmpty.setAttribute("aria-hidden", isEmpty ? "false" : "true");
          }
          if (messageInput) messageInput.disabled = isEmpty;
          if (sendBtn) sendBtn.disabled = isEmpty;
          if (emojiBtn) emojiBtn.disabled = isEmpty;
          if (attachBtn) attachBtn.disabled = isEmpty;
          if (fileInput) fileInput.disabled = isEmpty;
        };
        const setInboxLoading = (loading, options = {}) => {
          if (!inboxSkeleton) return;
          const shouldShow = loading === true;
          inboxSkeleton.style.display = shouldShow ? "grid" : "none";
          if (threadList) {
            threadList.style.display = shouldShow && !options.keepList ? "none" : "";
            threadList.classList.toggle("is-loading", shouldShow && !options.keepList);
          }
        };
        const updateSidebarCount = (count) => {
          if (!sidebarCount) return;
          const label = count === 1 ? "1 cuoc tro chuyen" : `${count} cuoc tro chuyen`;
          sidebarCount.textContent = label;
        };

        const buildConversationCacheKey = () => `${isAdminUser ? "admin" : "user"}:${selfUserId || rawUserId || ""}`;
        const buildConversationStorageKey = () => `${LIST_STORAGE_PREFIX}:${buildConversationCacheKey()}`;
        const buildActiveStorageKey = () => `${ACTIVE_STORAGE_PREFIX}:${buildConversationCacheKey()}`;
        const readConversationStorage = () => {
          try {
            const raw = sessionStorage.getItem(buildConversationStorageKey());
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || !Array.isArray(parsed.list) || !parsed.savedAt) return null;
            if (Date.now() - parsed.savedAt > LIST_CACHE_TTL_MS) return null;
            return parsed;
          } catch (error) {
            return null;
          }
        };
        const readConversationCache = () => {
          const key = buildConversationCacheKey();
          if (conversationCache.list && conversationCache.key === key && Date.now() - conversationCache.savedAt <= LIST_CACHE_TTL_MS) {
            return conversationCache.list;
          }
          const stored = readConversationStorage();
          if (!stored) return null;
          conversationCache.key = key;
          conversationCache.list = stored.list;
          conversationCache.savedAt = stored.savedAt;
          if (stored.etag) conversationListEtag = stored.etag;
          if (stored.version) conversationVersion = stored.version;
          return conversationCache.list;
        };
        const writeConversationCache = () => {
          if (!conversationList.length) return;
          conversationCache.key = buildConversationCacheKey();
          conversationCache.list = conversationList.slice();
          conversationCache.savedAt = Date.now();
          try {
            sessionStorage.setItem(
              buildConversationStorageKey(),
              JSON.stringify({
                list: conversationCache.list,
                savedAt: conversationCache.savedAt,
                etag: conversationListEtag || "",
                version: conversationVersion || "",
              })
            );
          } catch (error) {}
        };
        const readActiveConversation = () => {
          try {
            const raw = sessionStorage.getItem(buildActiveStorageKey());
            if (!raw) return "";
            const parsed = JSON.parse(raw);
            if (!parsed || !parsed.id || !parsed.savedAt) return "";
            if (Date.now() - parsed.savedAt > LIST_CACHE_TTL_MS) return "";
            return String(parsed.id);
          } catch (error) {
            return "";
          }
        };
        const writeActiveConversation = (conversationId) => {
          if (!conversationId) return;
          try {
            sessionStorage.setItem(
              buildActiveStorageKey(),
              JSON.stringify({ id: String(conversationId), savedAt: Date.now() })
            );
          } catch (error) {}
        };

        const getNavigationType = () => {
          try {
            const entries = performance && typeof performance.getEntriesByType === "function" ? performance.getEntriesByType("navigation") : [];
            if (entries && entries.length) return entries[0].type || "";
          } catch (error) {}
          return "";
        };

        if (!initialConversationId) {
          const navType = getNavigationType();
          if (navType === "reload") {
            const cachedActiveId = readActiveConversation();
            if (cachedActiveId) initialConversationId = cachedActiveId;
          }
        }

        if (queryConversationId) {
          setHistoryState(queryConversationId, { mode: "replace" });
        } else if (initialConversationId) {
          setHistoryState(initialConversationId, { mode: "replace" });
        }

        const readMessageCache = (conversationId) => {
          if (!conversationId) return null;
          const cached = messageCache.get(conversationId);
          if (!cached) return null;
          if (Date.now() - cached.savedAt > MESSAGE_CACHE_TTL_MS) {
            messageCache.delete(conversationId);
            return null;
          }
          return cached;
        };
        const writeMessageCache = (conversationId) => {
          if (!conversationId || !messageList.length) return;
          messageCache.set(conversationId, {
            messages: messageList.slice(),
            lastCursor: lastMessageCursor,
            oldestCursor: oldestMessageCursor,
            hasMore: hasMoreMessages,
            savedAt: Date.now(),
          });
        };
        const applyMessageCache = (cached) => {
          if (!cached || !Array.isArray(cached.messages)) return false;
          messageMap.clear();
          cached.messages.forEach((msg) => {
            if (msg && msg.id) messageMap.set(String(msg.id), msg);
          });
          messageList = Array.from(messageMap.values()).sort((a, b) => parseTimestamp(a.createdAt) - parseTimestamp(b.createdAt));
          lastMessageCursor = cached.lastCursor || "";
          oldestMessageCursor = cached.oldestCursor || "";
          hasMoreMessages = cached.hasMore === true;
          if (!lastMessageCursor || !oldestMessageCursor) updateCursors();
          return messageList.length > 0;
        };

        const muteKey = "bk_chat_mute_until";
        let muteUntil = 0;
        try {
          const stored = Number(localStorage.getItem(muteKey));
          if (Number.isFinite(stored) && stored > Date.now()) {
            muteUntil = stored;
          } else {
            localStorage.removeItem(muteKey);
          }
        } catch (e) {
          muteUntil = 0;
        }

        let lastSendAt = 0;
        const sendLog = [];
        const cooldownMs = 3000;
        const spamWindowMs = 60000;
        const spamLimit = 10;
        const muteMs = 60 * 60 * 1000;

        const canSendMessage = () => {
          const now = Date.now();
          if (muteUntil && now >= muteUntil) {
            muteUntil = 0;
            try {
              localStorage.removeItem(muteKey);
            } catch (e) {}
          }
          if (muteUntil && now < muteUntil) {
            const remainMin = Math.max(1, Math.ceil((muteUntil - now) / 60000));
            notify(`Ban dang bi tam khoa chat. Thu lai sau ${remainMin} phut.`);
            return false;
          }
          const sinceLast = now - lastSendAt;
          if (lastSendAt && sinceLast < cooldownMs) {
            const waitSec = Math.max(1, Math.ceil((cooldownMs - sinceLast) / 1000));
            notify(`Gui qua nhanh. Thu lai sau ${waitSec} giay.`);
            return false;
          }
          sendLog.push(now);
          const cutoff = now - spamWindowMs;
          while (sendLog.length && sendLog[0] < cutoff) {
            sendLog.shift();
          }
          if (sendLog.length > spamLimit) {
            muteUntil = now + muteMs;
            try {
              localStorage.setItem(muteKey, String(muteUntil));
            } catch (e) {}
            notify("Ban gui qua nhieu. Tam khoa 1 gio.");
            sendLog.length = 0;
            return false;
          }
          lastSendAt = now;
          return true;
        };

        const markBoost = () => {
          boostUntil = Math.max(boostUntil, Date.now() + MESSAGE_BOOST_WINDOW_MS);
          if (messageTimer) {
            clearTimeout(messageTimer);
            messageTimer = null;
            scheduleMessagePoll();
          }
        };

        const markActive = () => {
          lastActiveAt = Date.now();
        };
        const isIdle = () => Date.now() - lastActiveAt > IDLE_POLL_THRESHOLD_MS;
        ["mousemove", "keydown", "click", "touchstart"].forEach((eventName) => {
          document.addEventListener(eventName, markActive, { passive: true });
        });
        window.addEventListener("scroll", markActive, { passive: true });

        const getMessagePollInterval = () => {
          if (document.hidden || isIdle()) return MESSAGE_POLL_HIDDEN_MS;
          if (Date.now() < boostUntil) return MESSAGE_POLL_BOOST_MS;
          return MESSAGE_POLL_ACTIVE_MS;
        };

        const getChatPollInterval = () => (document.hidden || isIdle() ? CHAT_POLL_HIDDEN_MS : CHAT_POLL_ACTIVE_MS);

        const prefersReducedMotion = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        let shouldStickToBottom = true;
        const isNearBottom = () => {
          const distance = messageBody.scrollHeight - messageBody.scrollTop - messageBody.clientHeight;
          return distance <= 80;
        };

        const scrollToBottom = (options = {}) => {
          if (!messageBody) return;
          const force = options.force === true;
          const behavior = options.behavior === "smooth" && !prefersReducedMotion ? "smooth" : "auto";
          if (force) shouldStickToBottom = true;
          if (!force && !isNearBottom()) return;
          requestAnimationFrame(() => {
            if (!messageBody) return;
            if (!force && !isNearBottom()) return;
            const top = messageBody.scrollHeight;
            if (typeof messageBody.scrollTo === "function") {
              messageBody.scrollTo({ top, behavior });
            } else {
              messageBody.scrollTop = top;
            }
          });
        };

        const settleScrollToBottom = (options = {}) => {
          scrollToBottom(options);
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              scrollToBottom(options);
            });
          });
        };

        const watchMediaLoad = (nodes, options = {}) => {
          const list = Array.isArray(nodes) ? nodes : nodes ? [nodes] : [];
          const media = [];
          list.forEach((node) => {
            if (!node) return;
            if (node.matches && (node.matches("img") || node.matches("video"))) {
              media.push(node);
              return;
            }
            if (node.querySelectorAll) {
              node.querySelectorAll("img, video").forEach((el) => media.push(el));
            }
          });
          if (!media.length) {
            settleScrollToBottom(options);
            return;
          }
          let pending = 0;
          let fallbackTimer = null;
          const done = () => {
            pending -= 1;
            if (pending > 0) return;
            if (fallbackTimer) clearTimeout(fallbackTimer);
            settleScrollToBottom(options);
          };
          media.forEach((el) => {
            if (el.tagName === "IMG") {
              if (el.complete) return;
              pending += 1;
              el.addEventListener("load", done, { once: true });
              el.addEventListener("error", done, { once: true });
              return;
            }
            if (el.readyState >= 1) return;
            pending += 1;
            el.addEventListener("loadedmetadata", done, { once: true });
            el.addEventListener("error", done, { once: true });
          });
          if (!pending) {
            settleScrollToBottom(options);
            return;
          }
          fallbackTimer = setTimeout(() => {
            pending = 0;
            settleScrollToBottom(options);
          }, 1500);
        };

        const updateNewMessageButton = () => {
          if (!messageNewBtn) return;
          if (newMessageCount > 0) {
            messageNewBtn.textContent = `Tin moi (${newMessageCount})`;
            messageNewBtn.classList.add("show");
          } else {
            messageNewBtn.classList.remove("show");
          }
        };

        messageBody.addEventListener("scroll", () => {
          shouldStickToBottom = isNearBottom();
          if (shouldStickToBottom && newMessageCount) {
            newMessageCount = 0;
            updateNewMessageButton();
          }
          if (messageBody.scrollTop < 80) {
            loadOlderMessages();
          }
          markActive();
        });

        if (messageNewBtn) {
          messageNewBtn.addEventListener("click", () => {
            newMessageCount = 0;
            updateNewMessageButton();
            scrollToBottom({ behavior: "smooth", force: true });
          });
        }

        const formatTimestamp = (value) => {
          let date = value ? new Date(value) : new Date();
          if (Number.isNaN(date.getTime())) date = new Date();
          const dd = String(date.getDate()).padStart(2, "0");
          const mm = String(date.getMonth() + 1).padStart(2, "0");
          const yyyy = date.getFullYear();
          const hh = String(date.getHours()).padStart(2, "0");
          const min = String(date.getMinutes()).padStart(2, "0");
          return `${dd}/${mm}/${yyyy} ${hh}:${min}`;
        };

        const formatFileSize = (bytes) => {
          const size = Number(bytes || 0);
          if (!Number.isFinite(size) || size <= 0) return "0 B";
          const kb = size / 1024;
          if (kb < 1024) return `${kb.toFixed(1)} KB`;
          return `${(kb / 1024).toFixed(2)} MB`;
        };

        const escapeHtml = (value) =>
          String(value || "").replace(/[&<>"']/g, (char) => {
            const map = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" };
            return map[char] || char;
          });

        const parseTimestamp = (value) => {
          const parsed = Date.parse(value || "");
          return Number.isNaN(parsed) ? 0 : parsed;
        };

        const createClientId = () =>
          typeof crypto !== "undefined" && typeof crypto.randomUUID === "function"
            ? crypto.randomUUID()
            : `local-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;

        const ensureMessageContainers = () => {
          if (!messageBody) return;
          if (loadMoreWrap && emptyState && messageListWrap) return;
          loadMoreWrap = document.createElement("div");
          loadMoreWrap.className = "message-load";
          const loadBtn = document.createElement("button");
          loadBtn.type = "button";
          loadBtn.textContent = t("profile.messages.loadMore", "Tai them");
          loadMoreWrap.appendChild(loadBtn);
          loadMoreBtn = loadBtn;
          emptyState = document.createElement("div");
          emptyState.className = "empty-state";
          emptyState.style.marginTop = "10px";
          emptyState.style.display = "none";
          emptyState.innerHTML = `<strong>${t("empty.noData", "Chua co du lieu")}</strong>`;
          messageListWrap = document.createElement("div");
          messageListWrap.className = "message-list";
          const keepLoading = messageLoading && messageLoading.parentElement === messageBody ? messageLoading : null;
          messageBody.innerHTML = "";
          if (keepLoading) messageBody.appendChild(keepLoading);
          messageBody.appendChild(loadMoreWrap);
          messageBody.appendChild(messageListWrap);
          messageBody.appendChild(emptyState);
          loadBtn.addEventListener("click", () => loadOlderMessages());
          if (typeof ResizeObserver !== "undefined" && !messageResizeObserver) {
            messageResizeObserver = new ResizeObserver(() => {
              if (!shouldStickToBottom) return;
              if (messageResizeTick) return;
              messageResizeTick = requestAnimationFrame(() => {
                messageResizeTick = 0;
                scrollToBottom({ behavior: "auto", force: true });
              });
            });
            messageResizeObserver.observe(messageListWrap);
          }
        };

        const updateLoadMore = () => {
          if (!loadMoreWrap) return;
          loadMoreWrap.style.display = hasMoreMessages ? "flex" : "none";
        };

        const setLoadMoreLoading = (loading) => {
          if (!loadMoreBtn) return;
          loadMoreBtn.disabled = loading;
          loadMoreBtn.textContent = loading ? t("profile.messages.loading", "Dang tai...") : t("profile.messages.loadMore", "Tai them");
        };

        const updateChatLoading = () => {
          const hasActiveSelection = Boolean(activeConversationId || activeUserId);
          const showLoading =
            hasActiveSelection &&
            isChatOverlayLoading &&
            (isChatLoadingMessages || (!hasLoadedMessages && isChatLoadingConversations));
          if (messageBody) {
            messageBody.classList.toggle("is-loading", showLoading);
          }
          if (messageLoading) {
            messageLoading.setAttribute("aria-hidden", showLoading ? "false" : "true");
          }
          if (emptyState) {
            const showEmpty =
              allowEmptyLabels && hasActiveSelection && !showLoading && hasLoadedMessages && !messageList.length;
            emptyState.style.display = showEmpty ? "block" : "none";
          }
          if (sidebarFoot) {
            const showSidebarEmpty = allowEmptyLabels && !showLoading && hasLoadedConversationList && !conversationList.length;
            sidebarFoot.style.display = showSidebarEmpty ? "block" : "none";
          }
        };

        const setConversationsLoading = (loading, options = {}) => {
          if (isChatLoadingConversations === loading) return;
          isChatLoadingConversations = loading;
          if (!options.silent) {
            isChatOverlayLoading = isChatLoadingConversations || isChatLoadingMessages;
          }
          if (!options.silent) {
            setInboxLoading(loading);
          } else if (!loading) {
            setInboxLoading(false);
          }
          updateChatLoading();
        };

        const setMessagesLoading = (loading, options = {}) => {
          if (isChatLoadingMessages === loading) return;
          isChatLoadingMessages = loading;
          if (!options.silent) {
            isChatOverlayLoading = isChatLoadingConversations || isChatLoadingMessages;
          }
          updateChatLoading();
        };

        const setPollingIndicator = (loading) => {
          if (isPollingMessages === loading) return;
          isPollingMessages = loading;
        };

        const resetMessageView = () => {
          messageMap.clear();
          messageNodes.clear();
          pendingMessages.clear();
          messageList = [];
          renderedIds = new Set();
          renderedStart = 0;
          newMessageCount = 0;
          shouldStickToBottom = true;
          lastMessageCursor = "";
          oldestMessageCursor = "";
          hasMoreMessages = false;
          isLoadingOlderMessages = false;
          hasLoadedMessages = false;
          updateNewMessageButton();
          ensureMessageContainers();
          setPollingIndicator(false);
          updateChatLoading();
          if (messageListWrap) {
            messageListWrap.innerHTML = "";
          } else {
            messageBody.querySelectorAll(".message-row").forEach((row) => row.remove());
          }
          updateLoadMore();
        };

        const updateCursors = () => {
          if (!messageList.length) {
            lastMessageCursor = "";
            oldestMessageCursor = "";
            return;
          }
          let minId = null;
          let maxId = null;
          messageList.forEach((msg) => {
            if (!msg || msg.id == null) return;
            const idValue = Number(msg.id);
            if (!Number.isFinite(idValue)) return;
            if (minId === null || idValue < minId) minId = idValue;
            if (maxId === null || idValue > maxId) maxId = idValue;
          });
          if (minId === null || maxId === null) {
            const first = messageList[0];
            const last = messageList[messageList.length - 1];
            lastMessageCursor = last && last.id != null ? String(last.id) : "";
            oldestMessageCursor = first && first.id != null ? String(first.id) : "";
            return;
          }
          oldestMessageCursor = String(minId);
          lastMessageCursor = String(maxId);
        };

        const createMessageRow = (msg, options = {}) => {
          const outgoing = options.outgoing === true;
          const row = document.createElement("div");
          row.className = `message-row ${outgoing ? "outgoing" : "incoming"}${options.pending ? " pending" : ""}${
            options.failed ? " failed" : ""
          }`;
          if (!outgoing) {
            const avatar = document.createElement("div");
            avatar.className = "message-avatar mini";
            avatar.innerHTML = `<img src="${supportAvatar}" alt="BK" />`;
            row.appendChild(avatar);
          }
          const bubble = document.createElement("div");
          bubble.className = "message-bubble";
          const bodyType = String(msg.bodyType || "text");
          if (bodyType === "image" && msg.body) {
            row.classList.add("is-image");
            bubble.classList.add("is-image");
            const attachment = document.createElement("div");
            attachment.className = "message-attachment";
            const img = document.createElement("img");
            img.loading = "lazy";
            img.decoding = "async";
            img.src = msg.body;
            img.alt = "Image";
            attachment.appendChild(img);
            bubble.appendChild(attachment);
          } else {
            const text = document.createElement("p");
            text.textContent = msg.body || "";
            bubble.appendChild(text);
          }
          const time = document.createElement("span");
          time.className = "message-time";
          time.textContent = formatTimestamp(msg.createdAt);
          bubble.appendChild(time);
          if (options.status) {
            const status = document.createElement("span");
            status.className = "message-status";
            status.textContent = options.status;
            bubble.appendChild(status);
          }
          row.appendChild(bubble);
          if (msg.id) row.dataset.messageId = String(msg.id);
          if (options.clientId) row.dataset.clientId = options.clientId;
          return row;
        };

        const reconcilePendingMessages = (items) => {
          if (!Array.isArray(items)) return;
          items.forEach((msg) => {
            if (!msg) return;
            const clientId = String(msg.clientMessageId || msg.client_message_id || "").trim();
            if (!clientId) return;
            if (!pendingMessages.has(clientId)) return;
            finalizePendingMessage(clientId, {
              id: msg.id,
              senderId: msg.senderId,
              recipientId: msg.recipientId,
              body: msg.body,
              bodyType: msg.bodyType || msg.type || "text",
              createdAt: msg.createdAt,
            });
          });
        };

        const mergeMessages = (items) => {
          if (!Array.isArray(items)) return false;
          let changed = false;
          items.forEach((msg) => {
            if (!msg || !msg.id) return;
            const id = String(msg.id);
            const existing = messageMap.get(id);
            if (!existing) {
              messageMap.set(id, msg);
              changed = true;
              return;
            }
            const next = { ...existing, ...msg };
            if (next.body !== existing.body || next.bodyType !== existing.bodyType || next.createdAt !== existing.createdAt) {
              messageMap.set(id, next);
            }
          });
          if (changed) {
            messageList = Array.from(messageMap.values()).sort((a, b) => parseTimestamp(a.createdAt) - parseTimestamp(b.createdAt));
            updateCursors();
          }
          return changed;
        };

        const renderInitialMessages = (selfId) => {
          ensureMessageContainers();
          if (messageListWrap) {
            messageListWrap.innerHTML = "";
          } else {
            messageBody.querySelectorAll(".message-row").forEach((row) => row.remove());
          }
          renderedIds = new Set();
          if (!messageList.length) {
            updateChatLoading();
            updateLoadMore();
            return;
          }
          if (emptyState) emptyState.style.display = "none";
          renderedStart = 0;
          const fragment = document.createDocumentFragment();
          const addedRows = [];
          for (let i = renderedStart; i < messageList.length; i += 1) {
            const msg = messageList[i];
            if (!msg || !msg.id) continue;
            const id = String(msg.id);
            if (renderedIds.has(id)) continue;
            const outgoing = selfId && String(msg.senderId) === String(selfId);
            const row = createMessageRow({ ...msg, bodyType: msg.bodyType || "text" }, { outgoing });
            renderedIds.add(id);
            messageNodes.set(id, row);
            fragment.appendChild(row);
            addedRows.push(row);
          }
          if (messageListWrap) {
            messageListWrap.appendChild(fragment);
          } else {
            messageBody.appendChild(fragment);
          }
          updateLoadMore();
          watchMediaLoad(addedRows, { behavior: "auto", force: true });
        };

        const appendNewMessages = (selfId) => {
          if (!messageList.length) return;
          const shouldStick = shouldStickToBottom || isNearBottom();
          const pendingItems = [];
          for (let i = renderedStart; i < messageList.length; i += 1) {
            const msg = messageList[i];
            if (!msg || !msg.id) continue;
            const id = String(msg.id);
            if (renderedIds.has(id)) continue;
            pendingItems.push(msg);
          }
          if (!pendingItems.length) return;

          const batchSize = 12;
          let index = 0;
          const total = pendingItems.length;
          const addedRows = [];

          const appendBatch = () => {
            const fragment = document.createDocumentFragment();
            const end = Math.min(index + batchSize, total);
            for (; index < end; index += 1) {
              const msg = pendingItems[index];
              const id = String(msg.id);
              if (renderedIds.has(id)) continue;
              const outgoing = selfId && String(msg.senderId) === String(selfId);
              const row = createMessageRow({ ...msg, bodyType: msg.bodyType || "text" }, { outgoing });
              renderedIds.add(id);
              messageNodes.set(id, row);
              fragment.appendChild(row);
              addedRows.push(row);
            }
            if (messageListWrap) {
              messageListWrap.appendChild(fragment);
            } else {
              messageBody.appendChild(fragment);
            }
            if (index < total) {
              requestAnimationFrame(appendBatch);
              return;
            }
            if (shouldStick) {
              watchMediaLoad(addedRows, { behavior: "smooth", force: true });
            } else {
              newMessageCount += total;
              updateNewMessageButton();
            }
          };

          requestAnimationFrame(appendBatch);
        };

        const updateMessages = (items, selfId) => {
          const hadMessages = messageList.length > 0;
          reconcilePendingMessages(items);
          const changed = mergeMessages(items);
          if (!messageList.length) {
            ensureMessageContainers();
            updateChatLoading();
            updateLoadMore();
            return;
          }
          if (!hadMessages || !renderedIds.size) {
            renderInitialMessages(selfId);
            return;
          }
          if (changed) {
            appendNewMessages(selfId);
          }
        };

        const loadOlderMessages = async () => {
          if (!activeConversationId || !hasMoreMessages || !oldestMessageCursor) return;
          if (isLoadingMessages || isLoadingOlderMessages) return;
          isLoadingOlderMessages = true;
          setLoadMoreLoading(true);
          try {
            await loadMessages(activeConversationId, { before: oldestMessageCursor, delta: false, silent: true });
          } finally {
            isLoadingOlderMessages = false;
            setLoadMoreLoading(false);
          }
        };

        const QUICK_REPLIES = [
          {
            command: "/xinchao",
            text: "Chao ban, ban can minh ho tro van de gi a? Ban gui thong tin chi tiet, khi minh online minh se ho tro ngay.",
          },
          {
            command: "/giaodich",
            text: "Giao dich ngoai san admin khong ho tro/bao ve. Vui long can than lua dao.",
          },
          {
            command: "/huongdan",
            text: "Ban gui link san pham + anh loi + mo ta, minh kiem tra giup.",
          },
          {
            command: "/thoigian",
            text: "Minh se phan hoi som nhat co the. Cam on ban da cho.",
          },
        ];
        let quickReplyIndex = -1;
        let quickReplyItems = [];

        const isQuickRepliesOpen = () => quickRepliesEl && quickRepliesEl.classList.contains("open");

        const renderQuickReplies = (items) => {
          if (!quickRepliesEl) return;
          quickReplyItems = items || [];
          quickReplyIndex = 0;
          quickRepliesEl.innerHTML = quickReplyItems
            .map((item, index) => {
              const isActive = index === quickReplyIndex;
              return `
                <button class="quick-reply-item${isActive ? " active" : ""}" type="button" data-index="${index}">
                  <span class="quick-reply-cmd">${escapeHtml(item.command)}</span>
                  <span class="quick-reply-text">${escapeHtml(item.text)}</span>
                </button>
              `;
            })
            .join("");
        };

        const openQuickReplies = (items) => {
          if (!quickRepliesEl || !items || !items.length) return;
          renderQuickReplies(items);
          quickRepliesEl.classList.add("open");
          quickRepliesEl.setAttribute("aria-hidden", "false");
        };

        const closeQuickReplies = () => {
          if (!quickRepliesEl) return;
          quickRepliesEl.classList.remove("open");
          quickRepliesEl.setAttribute("aria-hidden", "true");
          quickRepliesEl.innerHTML = "";
          quickReplyItems = [];
          quickReplyIndex = -1;
        };

        const updateQuickReplies = () => {
          if (!isAdminUser || !messageInput || !quickRepliesEl) return;
          const raw = messageInput.value || "";
          const trimmed = raw.trim();
          if (!trimmed.startsWith("/")) {
            closeQuickReplies();
            return;
          }
          const query = trimmed.slice(1).toLowerCase();
          const matches = QUICK_REPLIES.filter((item) => item.command.slice(1).startsWith(query));
          if (!matches.length) {
            closeQuickReplies();
            return;
          }
          openQuickReplies(matches);
        };

        const moveQuickReply = (delta) => {
          if (!quickReplyItems.length || !quickRepliesEl) return;
          quickReplyIndex = (quickReplyIndex + delta + quickReplyItems.length) % quickReplyItems.length;
          quickRepliesEl.querySelectorAll(".quick-reply-item").forEach((node, index) => {
            node.classList.toggle("active", index === quickReplyIndex);
          });
        };

        const applyQuickReply = (item) => {
          if (!item || !messageInput) return;
          messageInput.value = item.text;
          closeQuickReplies();
          messageInput.focus();
        };

        document.addEventListener("click", (event) => {
          if (!isQuickRepliesOpen()) return;
          if (event.target.closest("#quick-replies") || event.target.closest("#message-input")) return;
          closeQuickReplies();
        });

        const isAdminProfile = (profile) => {
          if (!profile || typeof profile !== "object") return false;
          if (profile.is_admin === true || profile.is_admin === 1 || profile.is_admin === "1") return true;
          const roleValue = typeof profile.role === "string" ? profile.role.trim().toLowerCase() : "";
          if (roleValue) return roleValue === "admin";
          const usernameValue = typeof profile.username === "string" ? profile.username.trim().toLowerCase() : "";
          return usernameValue === "admin";
        };

        const getRoleLabel = (profile) => (isAdminProfile(profile) ? t("profile.messages.role.admin", "Admin") : "NgÆ°á»i DÃ¹ng");

        const applyRoleBadge = (profile) => {
          if (!headerRoleBadge) return;
          const isAdmin = isAdminProfile(profile);
          headerRoleBadge.textContent = isAdmin ? t("profile.messages.role.admin", "Admin") : "NgÆ°á»i DÃ¹ng";
          headerRoleBadge.classList.toggle("admin", isAdmin);
        };

        const setHeaderProfileLink = (profile) => {
          activeProfile = profile && typeof profile === "object" ? profile : null;
          if (!headerName) return;
          if (!activeProfile) {
            headerName.classList.remove("is-link");
            headerName.removeAttribute("data-profile-username");
            headerName.removeAttribute("data-profile-id");
            headerName.removeAttribute("role");
            headerName.removeAttribute("tabindex");
            return;
          }
          const username = activeProfile.username ? String(activeProfile.username) : "";
          const userId = activeProfile.id || activeProfile.userId || "";
          headerName.dataset.profileUsername = username;
          headerName.dataset.profileId = userId;
          const hasLink = Boolean(username || userId);
          headerName.classList.toggle("is-link", hasLink);
          if (hasLink) {
            headerName.setAttribute("role", "link");
            headerName.setAttribute("tabindex", "0");
          } else {
            headerName.removeAttribute("role");
            headerName.removeAttribute("tabindex");
          }
        };

        const applySupportProfile = (admin) => {
          if (!admin || typeof admin !== "object") return;
          const name = String(admin.display_name || admin.name || "").trim();
          const adminProfile = isAdminProfile(admin);
          const avatarUrl = typeof getAvatarUrl === "function" ? getAvatarUrl(admin) : String(admin.avatar_url || admin.avatar || "").trim();
          const id = admin.id != null ? normalizeUserId(admin.id) : "";
          if (id) supportUserId = id;
          if (admin.username) supportUsername = String(admin.username);
          lastStatusKey = "";
          heartbeatEtag = "";
          if (name) {
            document.querySelectorAll("[data-support-name]").forEach((el) => {
              if (applyNameWithBadge) {
                applyNameWithBadge(el, { name, isAdmin: adminProfile });
                return;
              }
              el.textContent = name;
            });
          }
          if (avatarUrl) supportAvatar = avatarUrl;
          document.querySelectorAll("[data-support-avatar]").forEach((img) => {
            img.src = supportAvatar;
          });
          applyRoleBadge(admin);
          setHeaderProfileLink(admin);
        };

        if (headerName) {
          headerName.addEventListener("click", () => {
            if (!activeProfile) return;
            openProfile(activeProfile);
          });
          headerName.addEventListener("keydown", (event) => {
            if (!activeProfile) return;
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              openProfile(activeProfile);
            }
          });
        }

        const ensurePrefillConversation = async () => {
          if (!isAdminUser) return null;
          if (!prefillTarget.userId && !prefillTarget.username) return null;
          const profile = await fetchPrefillProfile();
          if (!profile) return null;
          const userId = normalizeUserId(profile.id || prefillTarget.userId || profile.username || "");
          if (!userId) return null;
          const existing = conversationList.find((item) => String(item.userId) === String(userId));
          const userProfile = {
            id: profile.id || userId,
            username: profile.username || prefillTarget.username || "",
            display_name: profile.display_name || profile.name || profile.username || "",
            avatar_url: profile.avatar_url || profile.avatar || "",
            role: profile.role || "",
            is_admin: profile.is_admin,
          };
          let targetConversation = existing;
          if (!targetConversation) {
            targetConversation = {
              userId,
              conversationId: "",
              user: userProfile,
              lastAt: "",
              lastMessage: "",
            };
            conversationList = [targetConversation, ...conversationList];
          } else if (targetConversation.user) {
            targetConversation.user = { ...targetConversation.user, ...userProfile };
          }
          if (!prefillApplied) {
            if (!activeUserId || String(activeUserId) !== String(userId)) {
              openConversation(targetConversation, { historyMode: "replace" });
              setDetailView(true);
            }
            prefillApplied = true;
          }
          return targetConversation;
        };

        const mergeConversationList = (items, extra) => {
          const next = Array.isArray(items) ? [...items] : [];
          if (!extra) return next;
          const extraId = String(extra.conversationId || "");
          let existing = extraId ? next.find((item) => String(item.conversationId || "") === extraId) : null;
          if (!existing && extra.userId) {
            existing = next.find((item) => String(item.userId) === String(extra.userId));
          }
          if (existing) {
            if (extra.user) existing.user = { ...existing.user, ...extra.user };
            if (extra.conversationId) existing.conversationId = extra.conversationId;
            return next;
          }
          return [extra, ...next];
        };

        const isSupportConversation = (item) => {
          if (!item) return false;
          const typeValue = String(item.type || item.conversationType || item.conversation_type || "").trim().toLowerCase();
          if (typeValue) return typeValue === "support";
          return isAdminProfile(item.user);
        };

        const getConversationSortTime = (item) => {
          if (!item) return 0;
          const raw = item.lastAt || item.updatedAt || item.updated_at || "";
          const time = Date.parse(raw);
          if (Number.isFinite(time)) return time;
          const updated = Date.parse(item.updatedAt || item.updated_at || "");
          return Number.isFinite(updated) ? updated : 0;
        };

        const resolveConversationKey = (item) => {
          if (!item) return "";
          const userId = normalizeUserId(item.userId || (item.user && item.user.id) || "");
          if (userId) return `user:${userId}`;
          const convoId = String(item.conversationId || "").trim();
          return convoId ? `convo:${convoId}` : "";
        };

        const pickConversation = (current, candidate, options = {}) => {
          if (!current) return candidate;
          if (!candidate) return current;
          const preferId = String(options.preferId || "");
          const currentId = String(current.conversationId || "");
          const candidateId = String(candidate.conversationId || "");
          if (preferId) {
            if (candidateId && candidateId === preferId) return candidate;
            if (currentId && currentId === preferId) return current;
          }
          const currentSupport = isSupportConversation(current);
          const candidateSupport = isSupportConversation(candidate);
          if (currentSupport !== candidateSupport) return candidateSupport ? candidate : current;
          const currentTime = getConversationSortTime(current);
          const candidateTime = getConversationSortTime(candidate);
          if (currentTime !== candidateTime) return candidateTime > currentTime ? candidate : current;
          if (candidateId && !currentId) return candidate;
          if (currentId && !candidateId) return current;
          if (!candidateId || !currentId) return current;
          return candidateId.localeCompare(currentId) > 0 ? candidate : current;
        };

        const dedupeConversationList = (items, options = {}) => {
          const list = Array.isArray(items) ? items : [];
          const map = new Map();
          list.forEach((item) => {
            const key = resolveConversationKey(item);
            if (!key) return;
            map.set(key, pickConversation(map.get(key), item, options));
          });
          return Array.from(map.values());
        };

        const sortConversationList = (items, options = {}) => {
          const list = dedupeConversationList(items, options);
          list.sort((a, b) => {
            const aPinned = isSupportConversation(a);
            const bPinned = isSupportConversation(b);
            if (aPinned !== bPinned) return aPinned ? -1 : 1;
            const aTime = getConversationSortTime(a);
            const bTime = getConversationSortTime(b);
            if (aTime !== bTime) return bTime - aTime;
            const aKey = String((a && (a.conversationId || a.userId)) || "");
            const bKey = String((b && (b.conversationId || b.userId)) || "");
            return aKey.localeCompare(bKey);
          });
          return list;
        };

        const renderThreadList = (items, options = {}) => {
          if (!threadList) return;
          const isFiltered = options.filtered === true;
          const emptyLabel = options.emptyText || t("profile.messages.search.empty", "Khong tim thay");
          if (!items || !items.length) {
            if (isFiltered) {
              threadList.innerHTML = `<div class="message-thread-empty">${emptyLabel}</div>`;
              updateSidebarCount(conversationList.length || 0);
              if (sidebarFoot) sidebarFoot.textContent = "";
              return;
            }
            threadList.innerHTML = "";
            updateSidebarCount(0);
            if (sidebarFoot) {
              sidebarFoot.textContent = t("profile.messages.thread.empty", "Khong co cuoc tro chuyen khac.");
              sidebarFoot.style.display = "none";
            }
            if (isAdminUser) {
              resetMessageView();
              if (emptyState) {
                emptyState.innerHTML = `
                  <strong>${t("profile.messages.thread.empty", "Khong co cuoc tro chuyen khac.")}</strong>
                  <p>Hop thu ho tro danh cho khach hang.</p>
                `;
                emptyState.style.display = "none";
              }
              if (inputWrap) inputWrap.style.display = "none";
            } else {
              resetMessageView();
            }
            return;
          }
          updateSidebarCount(items.length);
          if (sidebarFoot) sidebarFoot.textContent = "";
          threadList.innerHTML = items
            .map((item) => {
              const user = item.user || {};
          const rawName = String(user.display_name || user.username || "User");
          const name = escapeHtml(rawName);
          const avatar = escapeHtml(typeof getAvatarUrl === "function" ? getAvatarUrl(user) : "../../asset/avt-macdinh.jpg");
          const isPeerAdmin = isAdminProfile(user);
          const roleLabel = getRoleLabel(user);
          const roleClass = isPeerAdmin ? " admin" : "";
          const time = item.lastAt ? formatTimestamp(item.lastAt) : "--";
          const previewText = item.lastMessage ? escapeHtml(item.lastMessage).slice(0, 40) : "--";
          const active = activeConversationId
            ? String(item.conversationId) === String(activeConversationId)
            : String(item.userId) === String(activeUserId);
          const nameHtml = renderNameWithBadge ? renderNameWithBadge(rawName, isPeerAdmin) : name;
          const profileUsername = user.username ? String(user.username) : "";
          const profileId = user.id || item.userId || "";
          return `
                <button class="message-thread${active ? " active" : ""}" type="button" data-user-id="${escapeHtml(
                  item.userId
                )}" data-conversation-id="${escapeHtml(item.conversationId || "")}">
                  <div class="message-avatar">
                    <img src="${avatar}" alt="${name}" />
                  </div>
                  <div class="message-thread-info">
                    <div class="message-thread-top">
                      <span class="message-thread-name message-thread-name-link" data-profile-username="${escapeHtml(
                        profileUsername
                      )}" data-profile-id="${escapeHtml(profileId)}">${nameHtml}</span>
                      <span class="message-thread-time">${time}</span>
                    </div>
                    <div class="message-thread-bottom">
                      <span class="message-thread-note">${previewText || "--"}</span>
                      <span class="message-role${roleClass}">${escapeHtml(roleLabel)}</span>
                    </div>
                  </div>
                </button>
              `;
            })
            .join("");
        };

        const fetchDirectTargetProfile = async () => {
          if (!hasDirectTarget()) return null;
          if (isFile) return null;
          if (directProfile || directFailed) return directProfile;
          const params = new URLSearchParams();
          if (directTarget.username) {
            params.set("u", directTarget.username);
          } else if (directTarget.userId) {
            params.set("id", directTarget.userId);
          } else {
            directFailed = true;
            return null;
          }
          params.set("view", "chat");
          try {
            const response = await fetch(`/api/profile?${params.toString()}`);
            const data = await response.json().catch(() => null);
            if (!response.ok || !data || !data.user) {
              directFailed = true;
              return null;
            }
            directProfile = data.user;
            if (!directTarget.userId) {
              const resolvedId = normalizeUserId(data.user.id || data.user.userId || data.user.username || "");
              if (resolvedId) directTarget.userId = resolvedId;
            }
            if (!directTarget.username && data.user.username) {
              directTarget.username = String(data.user.username);
            }
            return directProfile;
          } catch (error) {
            directFailed = true;
            return null;
          }
        };

        const ensureDirectConversation = async () => {
          if (!hasDirectTarget() || isAdminUser) return null;
          if (directConversation) return directConversation;
          if (directFailed) return null;
          const profile = await fetchDirectTargetProfile();
          if (!profile) {
            directFailed = true;
            return null;
          }
          if (isAdminProfile(profile)) {
            directFailed = true;
            return null;
          }
          const selfId = normalizeUserId(selfUserId || rawUserId);
          const targetId = normalizeUserId(profile.id || profile.userId || profile.username || directTarget.userId || "");
          if (!selfId || !targetId) {
            directFailed = true;
            return null;
          }
          const conversationId = buildDirectConversationId(selfId, targetId);
          if (!conversationId) {
            directFailed = true;
            return null;
          }
          const userProfile = {
            id: profile.id || targetId,
            username: profile.username || directTarget.username || "",
            display_name: profile.display_name || profile.name || profile.username || "",
            avatar_url: profile.avatar_url || profile.avatar || "",
            role: profile.role || "",
            is_admin: profile.is_admin,
          };
          directConversation = {
            userId: targetId,
            conversationId,
            user: userProfile,
            lastAt: "",
            lastMessage: "",
            lastType: "",
          };
          return directConversation;
        };

        const normalizeSearchTerm = (value) => String(value || "").trim().toLowerCase();

        let markReadTick = 0;
        let lastMarkedId = "";
        const markMessagesRead = (conversationId) => {
          if (isFile || !rawUserId) return;
          const nextId = conversationId ? String(conversationId) : "";
          const markKey = nextId || "__all__";
          if (markKey === lastMarkedId) return;
          if (markReadTick) cancelAnimationFrame(markReadTick);
          markReadTick = requestAnimationFrame(async () => {
            markReadTick = 0;
            lastMarkedId = markKey;
            try {
              const response = await fetch("/api/conversations/mark-read", {
                method: "POST",
                headers: {
                  "content-type": "application/json",
                  ...buildAuthHeaders(),
                },
                body: JSON.stringify(nextId ? { conversationId: nextId } : {}),
              });
              if (!response.ok) return;
              if (window.BKNotifier && typeof window.BKNotifier.refresh === "function") {
                window.BKNotifier.refresh({ force: true });
              }
            } catch (error) {}
          });
        };

        const getConversationSearchText = (item) => {
          if (!item) return "";
          const user = item.user || {};
          const parts = [
            user.display_name || "",
            user.username || "",
            item.userId || "",
            item.lastMessage || "",
            item.lastType || "",
          ];
          return parts.filter(Boolean).join(" ").toLowerCase();
        };

        const updateSearchUI = () => {
          if (!searchWrap) return;
          const hasValue = searchValue.length > 0;
          searchWrap.classList.toggle("has-value", hasValue);
        };

        const applySearchFilter = () => {
          if (!threadList) return;
          const term = normalizeSearchTerm(searchValue);
          if (!term) {
            renderThreadList(conversationList);
            return;
          }
          const filtered = conversationList.filter((item) => getConversationSearchText(item).includes(term));
          renderThreadList(filtered, { filtered: true });
        };

        const setActiveConversation = (conversation) => {
          if (!conversation) return;
          const previousConversationId = activeConversationId;
          if (previousConversationId) writeMessageCache(previousConversationId);
          abortMessageFetch();
          setConversationEmptyState(false);
          activeUserId = conversation.userId ? normalizeUserId(conversation.userId) : "";
          activeConversationId = conversation.conversationId ? String(conversation.conversationId) : "";
          if (activeConversationId) {
            writeActiveConversation(activeConversationId);
          }
          if (activeConversationId) {
            markMessagesRead(activeConversationId);
          }
          if (conversation.user) {
            applySupportProfile({
              id: conversation.user.id || activeUserId,
              username: conversation.user.username || "",
              display_name: conversation.user.display_name || conversation.user.username || "",
              avatar_url: conversation.user.avatar_url || "",
              role: conversation.user.role || "",
              is_admin: conversation.user.is_admin,
            });
          }
          if (inputWrap) inputWrap.style.display = "";
          resetMessageView();
          currentConversationKey = activeConversationId || "";
          renderThreadList(conversationList);
          if (activeConversationId) {
            const cached = readMessageCache(activeConversationId);
            if (cached && applyMessageCache(cached)) {
              renderInitialMessages(selfUserId || resolvedUserId || rawUserId);
              hasLoadedMessages = true;
              updateChatLoading();
              updateLoadMore();
              loadMessages(activeConversationId, { reset: false, delta: false, silent: true });
            } else {
              loadMessages(activeConversationId, { reset: true, delta: false });
            }
          }
          if (!pollEnabled) {
            ensurePollingEnabled();
          } else {
            loadChatHeartbeat({ force: true });
            startMessagePolling();
          }
        };

        const openConversation = (conversation, options = {}) => {
          if (!conversation) {
            setConversationEmptyState(true);
            if (options.history !== false) setHistoryState("", { mode: "replace" });
            return false;
          }
          setActiveConversation(conversation);
          if (options.history !== false && conversation.conversationId) {
            const mode = options.historyMode === "push" ? "push" : "replace";
            setHistoryState(conversation.conversationId, { mode });
          }
          return true;
        };

        const clearActiveConversation = (options = {}) => {
          if (activeConversationId) writeMessageCache(activeConversationId);
          abortMessageFetch();
          activeConversationId = "";
          activeUserId = "";
          currentConversationKey = "";
          stopMessagePolling();
          renderThreadList(conversationList);
          setConversationEmptyState(true);
          if (options.history !== false) setHistoryState("", { mode: "replace" });
        };

        const findConversationById = (conversationId) =>
          conversationList.find((item) => String(item.conversationId || "") === String(conversationId));

        let pendingConversationId = "";
        const openConversationById = (conversationId, options = {}) => {
          const targetId = conversationId ? String(conversationId) : "";
          if (!targetId) {
            clearActiveConversation({ history: options.history });
            return false;
          }
          const conversation = findConversationById(targetId);
          if (conversation) {
            return openConversation(conversation, options);
          }
          pendingConversationId = targetId;
          return false;
        };

        const loadConversationList = async (options = {}) => {
          if (isFile || isLoadingList) return;
          const isSilent = options.silent === true;
          const requestToken = (listRequestToken += 1);
          isLoadingList = true;
          let cachedList = null;
          if (!isSilent && !hasLoadedConversationList) {
            cachedList = readConversationCache();
          }
          const hasCache = cachedList && cachedList.length;
          setConversationsLoading(true, { silent: isSilent || hasCache });
          let directCandidate = null;
          if (hasCache) {
            conversationList = cachedList.slice();
            conversationList = sortConversationList(conversationList, { preferId: initialConversationId });
            hasLoadedConversationList = true;
            renderThreadList(conversationList);
            updateSidebarCount(conversationList.length);
            if (initialConversationId && !requestedApplied && !activeConversationId) {
              if (openConversationById(initialConversationId, { historyMode: "replace" })) {
                setDetailView(true);
                requestedApplied = true;
              }
            }
            isChatOverlayLoading = false;
            updateChatLoading();
            if (!activeConversationId && !activeUserId) {
              setConversationEmptyState(true);
            }
          }
          try {
            const params = new URLSearchParams();
            if (isAdminUser) {
              params.set("admin", "1");
              const adminRef = selfUserId || rawUserId;
              if (adminRef) params.set("adminId", String(adminRef));
            } else if (rawUserId) {
              params.set("userId", String(rawUserId));
            }
            const query = params.toString();
            const url = query ? `${conversationsUrl}?${query}` : conversationsUrl;
            const headers = {};
            if (hasLoadedConversationList && conversationListEtag) {
              headers["if-none-match"] = conversationListEtag;
            }
            const response = await fetchDedup(url, { headers, cache: "no-store" });
            if (response.status === 304) {
              const nextEtag = response.headers.get("etag");
              if (nextEtag) conversationListEtag = nextEtag;
              return;
            }
            if (!response.ok) throw new Error("request_failed");
            const data = await response.json().catch(() => null);
            if (!data || !data.ok) throw new Error("invalid_response");
            const nextEtag = response.headers.get("etag");
            if (nextEtag) conversationListEtag = nextEtag;
            hasLoadedConversationList = true;
            if (data.conversationsVersion || data.conversations_version) {
              conversationVersion = String(data.conversationsVersion || data.conversations_version || "");
            }
            if (data.adminId) {
              adminId = normalizeUserId(data.adminId);
              if (isAdminUser) selfUserId = adminId;
            }
            conversationList = Array.isArray(data.conversations) ? data.conversations : [];
            if (!isAdminUser && data.admin) applySupportProfile(data.admin);
            if (hasDirectTarget()) {
              directCandidate = await ensureDirectConversation();
              if (directCandidate) {
                conversationList = mergeConversationList(conversationList, directCandidate);
              }
            }
            await ensurePrefillConversation();
            conversationList = sortConversationList(conversationList, { preferId: initialConversationId });
            if (initialConversationId && !requestedApplied) {
              if (openConversationById(initialConversationId, { historyMode: "replace" })) {
                setDetailView(true);
                requestedApplied = true;
                return;
              }
            }
            if (directCandidate && !directApplied) {
              openConversationById(directCandidate.conversationId, { historyMode: "replace" });
              setDetailView(true);
              directApplied = true;
              return;
            }
            const nextKey = conversationList
              .map((item) => `${item.conversationId || ""}:${item.lastAt || ""}:${item.lastMessage || ""}`)
              .join("|");
            if (nextKey !== conversationListKey) {
              conversationListKey = nextKey;
              if (searchValue) {
                applySearchFilter();
              } else {
                renderThreadList(conversationList);
              }
            }
            if (activeConversationId) {
              const current = conversationList.find((item) => String(item.conversationId) === String(activeConversationId));
              if (current && current.user) {
                applySupportProfile({
                  id: current.user.id || current.userId || "",
                  username: current.user.username || "",
                  display_name: current.user.display_name || current.user.username || "",
                  avatar_url: current.user.avatar_url || "",
                  role: current.user.role || "",
                  is_admin: current.user.is_admin,
                });
              }
            }
            writeConversationCache();
            if (pendingConversationId) {
              const pendingId = pendingConversationId;
              pendingConversationId = "";
              const pendingConversation = findConversationById(pendingId);
              if (pendingConversation) {
                openConversation(pendingConversation, { historyMode: "replace" });
                setDetailView(true);
              } else {
                clearActiveConversation({ history: false });
              }
            }
            if (!activeConversationId && !activeUserId) {
              setConversationEmptyState(true);
            }
          } catch (error) {
            if (!isSilent) {
              renderThreadList([]);
            }
          } finally {
            if (requestToken === listRequestToken) isLoadingList = false;
            setConversationsLoading(false, { silent: isSilent });
          }
        };

        if (threadList) {
          threadList.addEventListener("click", (event) => {
            const nameTarget = event.target.closest(".message-thread-name-link");
            if (nameTarget && threadList.contains(nameTarget)) {
              event.preventDefault();
              event.stopPropagation();
              const username = nameTarget.dataset.profileUsername || "";
              const userId = nameTarget.dataset.profileId || "";
              openProfile({ username, id: userId });
              return;
            }
            const btn = event.target.closest(".message-thread");
            if (!btn) return;
            setDetailView(true);
            const convoId = btn.dataset.conversationId || "";
            const userId = btn.dataset.userId || "";
            const conversation = convoId
              ? conversationList.find((item) => String(item.conversationId) === String(convoId))
              : conversationList.find((item) => String(item.userId) === String(userId));
            if (conversation) {
              if (conversation.conversationId) {
                openConversationById(conversation.conversationId, { historyMode: "push" });
              } else {
                openConversation(conversation, { historyMode: "push" });
              }
            }
          });
        }

        window.addEventListener("popstate", (event) => {
          const stateId = event && event.state && event.state.conversationId ? String(event.state.conversationId) : "";
          if (stateId) {
            const opened = openConversationById(stateId, { history: false });
            setDetailView(true);
            if (!opened) {
              setConversationEmptyState(true);
            }
            return;
          }
          clearActiveConversation({ history: false });
          setDetailView(false);
        });

        if (searchInput) {
          searchInput.addEventListener("input", () => {
            searchValue = searchInput.value || "";
            updateSearchUI();
            if (searchTimer) clearTimeout(searchTimer);
            searchTimer = setTimeout(() => {
              applySearchFilter();
            }, 250);
          });
        }

        if (searchClear) {
          searchClear.addEventListener("click", () => {
            searchValue = "";
            if (searchInput) searchInput.value = "";
            updateSearchUI();
            applySearchFilter();
            if (searchInput) searchInput.focus();
          });
        }


        const formatStatus = (lastSeen, isOnline) => {
          if (isOnline) return "Dang online";
          const raw = Number(lastSeen || 0);
          if (!raw) return "Ngoai tuyen";
          const lastMs = raw > 1000000000000 ? raw : raw * 1000;
          const diffMs = Math.max(0, Date.now() - lastMs);
          const minutes = Math.floor(diffMs / 60000);
          if (minutes < 1) return "Vua hoat dong";
          if (minutes < 60) {
            return `Hoat dong ${minutes} phut truoc`;
          }
          const hours = Math.floor(minutes / 60);
          if (hours < 24) {
            return `Hoat dong ${hours} gio truoc`;
          }
          const days = Math.floor(hours / 24);
          if (days === 1) return "Hom qua";
          return `Hoat dong ${days} ngay truoc`;
        };

        const updateSupportStatus = (status) => {
          if (!status) return;
          const isOnline = status.online === true || status.is_online === true;
          const lastSeen = status.lastSeenAt ?? status.last_seen_at ?? status.lastSeen ?? 0;
          const nextKey = `${isOnline ? 1 : 0}:${Number(lastSeen) || 0}`;
          if (nextKey === lastStatusKey) return;
          lastStatusKey = nextKey;
          const text = formatStatus(lastSeen, isOnline);
          document.querySelectorAll("[data-support-status]").forEach((el) => {
            el.textContent = text;
            el.classList.toggle("is-online", isOnline);
          });
        };

        updateSupportStatus({ online: false, lastSeen: 0 });

        const buildPingPayload = () => {
          const userId = normalizeUserId(selfUserId || rawUserId || user.id || "");
          const username = user && user.username ? String(user.username).trim() : "";
          const email = user && user.email ? String(user.email).trim() : "";
          if (!userId && !username && !email) return null;
          const payload = {};
          if (userId) payload.userId = userId;
          if (username) payload.username = username;
          if (email) payload.email = email;
          return payload;
        };

        const sendPing = async (options = {}) => {
          if (isFile || isPinging || !pollEnabled) return;
          const payload = buildPingPayload();
          if (!payload) return;
          const now = Date.now();
          const interval = document.hidden ? PING_HIDDEN_MS : PING_ACTIVE_MS;
          if (!options.force && now - lastPingAt < interval) return;
          isPinging = true;
          lastPingAt = now;
          try {
            await fetch(pingUrl, {
              method: "POST",
              headers: { "content-type": "application/json" },
              body: JSON.stringify(payload),
              cache: "no-store",
              keepalive: options.keepalive === true,
            });
          } catch (error) {} finally {
            isPinging = false;
          }
        };

        const buildHeartbeatUrl = () => {
          const params = new URLSearchParams();
          const selfId = normalizeUserId(selfUserId || rawUserId || "");
          const refId = normalizeUserId(supportUserId || "");
          const ref = refId || supportUsername;
          if (selfId) params.set("userId", selfId);
          if (ref) params.set("u", ref);
          const query = params.toString();
          if (!query) return "";
          return `${heartbeatUrl}?${query}`;
        };

        const ensurePollingEnabled = () => {
          if (isFile || pollEnabled) return;
          pollEnabled = true;
          startMessagePolling();
          startChatPolling();
          startPingPolling();
        };

        const schedulePollingStart = () => {
          if (isFile || pollStartScheduled) return;
          pollStartScheduled = true;
          const start = () => {
            if (shouldAutoStartPolling || activeConversationId || activeUserId) {
              ensurePollingEnabled();
            }
          };
          if (typeof requestIdleCallback === "function") {
            requestIdleCallback(start, { timeout: 800 });
          } else {
            setTimeout(start, 0);
          }
        };

        const startPingPolling = () => {
          if (isFile || !pollEnabled || pingTimer) return;
          pingTimer = setInterval(() => {
            sendPing();
          }, PING_ACTIVE_MS);
          sendPing({ force: true });
        };

        const stopPingPolling = () => {
          if (!pingTimer) return;
          clearInterval(pingTimer);
          pingTimer = null;
        };

        const restartPingPolling = () => {
          stopPingPolling();
          startPingPolling();
        };

        const loadChatHeartbeat = async (options = {}) => {
          if (isFile || isLoadingHeartbeat || !pollEnabled) return;
          const url = buildHeartbeatUrl();
          if (!url) return;
          const now = Date.now();
          if (!options.force && (document.hidden || isIdle()) && now - lastHeartbeatAt < CHAT_POLL_HIDDEN_MS) return;
          isLoadingHeartbeat = true;
          lastHeartbeatAt = now;
          try {
            const headers = {};
            if (heartbeatEtag) headers["if-none-match"] = heartbeatEtag;
            const response = await fetchDedup(url, { headers, cache: "no-store" });
            if (response.status === 304) {
              const nextEtag = response.headers.get("etag");
              if (nextEtag) heartbeatEtag = nextEtag;
              if (lastHeartbeatPayload) {
                updateSupportStatus({
                  online: lastHeartbeatPayload.online,
                  lastSeenAt: lastHeartbeatPayload.lastSeenAt,
                  lastSeen: lastHeartbeatPayload.lastSeen,
                });
                const nextVersion = lastHeartbeatPayload.conversationsVersion || "";
                if (nextVersion && nextVersion !== conversationVersion) {
                  conversationVersion = String(nextVersion);
                  loadConversationList({ silent: true });
                }
                const nextUnread = Number(lastHeartbeatPayload.unreadCount || 0);
                if (Number.isFinite(nextUnread)) unreadCount = nextUnread;
              }
              return;
            }
            if (!response.ok) return;
            const data = await response.json().catch(() => null);
            if (!data || !data.ok) return;
            const nextEtag = response.headers.get("etag");
            if (nextEtag) heartbeatEtag = nextEtag;
            const nextLastSeen =
              data.lastSeenAt ?? data.lastSeen ?? data.lastSeenMs ?? data.last_seen_at ?? data.last_seen_ms ?? 0;
            updateSupportStatus({ online: data.online, lastSeenAt: nextLastSeen, lastSeen: nextLastSeen });
            const nextVersion = data.conversationsVersion || data.conversations_version || "";
            if (nextVersion && nextVersion !== conversationVersion) {
              conversationVersion = String(nextVersion);
              loadConversationList({ silent: true });
            }
            const nextUnread = Number(data.unreadCount || data.unread_count || 0);
            if (Number.isFinite(nextUnread)) unreadCount = nextUnread;
            lastHeartbeatPayload = {
              online: data.online === true,
              lastSeenAt: nextLastSeen,
              lastSeen: nextLastSeen,
              conversationsVersion: nextVersion,
              unreadCount: Number.isFinite(nextUnread) ? nextUnread : 0,
            };
          } catch (error) {} finally {
            isLoadingHeartbeat = false;
          }
        };

        const startChatPolling = () => {
          if (isFile || !pollEnabled) return;
          if (window.__chatPoller) return;
          const interval = getChatPollInterval();
          window.__chatPoller = setInterval(() => {
            loadChatHeartbeat();
          }, interval);
          loadChatHeartbeat({ force: true });
        };

        const stopChatPolling = () => {
          if (!window.__chatPoller) return;
          clearInterval(window.__chatPoller);
          window.__chatPoller = null;
        };

        const restartChatPolling = () => {
          stopChatPolling();
          startChatPolling();
        };

        if (!isFile) {
          document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
              stopMessagePolling();
              stopChatPolling();
              stopPingPolling();
              return;
            }
            startMessagePolling();
            restartChatPolling();
            restartPingPolling();
            sendPing({ force: true });
          });
          window.addEventListener("beforeunload", () => {
            sendPing({ force: true, keepalive: true });
            stopChatPolling();
            stopPingPolling();
          });
          window.addEventListener("pagehide", () => {
            sendPing({ force: true, keepalive: true });
            stopChatPolling();
            stopPingPolling();
          });
        }

        const loadMessages = async (conversationId, options = {}) => {
          if (isFile || !conversationId) return;
          const resetView = options.reset === true;
          const isSilent = options.silent === true;
          const beforeCursor = options.before ? String(options.before) : "";
          const isDelta = options.delta === true;
          const sinceCursor = isDelta ? String(options.since || lastMessageCursor || "") : "";
          const isOlderLoad = Boolean(beforeCursor);
          if (resetView) {
            resetMessageView();
            abortMessageFetch();
          }
          const shouldShowLoading = !isDelta && !isOlderLoad && (resetView || (!messageList.length && pendingMessages.size === 0));
          if (shouldShowLoading) setMessagesLoading(true, { silent: isSilent });
          const requestToken = (messageRequestToken += 1);
          let controller = null;
          try {
            const params = new URLSearchParams();
            params.set("conversationId", conversationId);
            if (beforeCursor) params.set("before", beforeCursor);
            if (sinceCursor) params.set("since", sinceCursor);
            params.set("limit", String(PAGE_SIZE));
            if (isAdminUser) {
              params.set("admin", "1");
              const adminRef = selfUserId || rawUserId;
              if (adminRef) params.set("adminId", String(adminRef));
            }
            const url = `${apiUrl}?${params.toString()}`;
            const inflightKey = buildInflightKey(url);
            if (isLoadingMessages && !inflightRequests.has(inflightKey) && !resetView && !isOlderLoad) return;
            isLoadingMessages = true;
            if (isDelta) setPollingIndicator(true);
            const fetchOptions = { cache: "no-store" };
            if (!inflightRequests.has(inflightKey)) {
              controller = new AbortController();
              messageFetchController = controller;
              fetchOptions.signal = controller.signal;
            }
            const response = inflightRequests.has(inflightKey)
              ? await inflightRequests.get(inflightKey)
              : await fetchDedup(url, fetchOptions);
            if (!response.ok) throw new Error("request_failed");
            const data = await response.json().catch(() => null);
            if (!data || !Array.isArray(data.messages)) throw new Error("invalid_response");
            if (requestToken !== messageRequestToken) return;
            resolvedUserId = data.userId ? normalizeUserId(data.userId) : resolvedUserId;
            if (data.adminId) {
              adminId = normalizeUserId(data.adminId);
              if (isAdminUser) selfUserId = adminId;
            }
            if (!isAdminUser && data.admin) applySupportProfile(data.admin);
            if (isAdminUser && data.user) applySupportProfile(data.user);
            const nextConversation = data.conversationId ? String(data.conversationId) : conversationId;
            if (nextConversation && nextConversation !== currentConversationKey) {
              currentConversationKey = nextConversation;
              if (!resetView) resetMessageView();
            }
            if (isOlderLoad) {
              const newItems = data.messages.filter((msg) => msg && msg.id && !messageMap.has(String(msg.id)));
              mergeMessages(data.messages);
              if (newItems.length) {
                const prevHeight = messageBody.scrollHeight;
                const prevTop = messageBody.scrollTop;
                const fragment = document.createDocumentFragment();
                newItems.forEach((msg) => {
                  const id = String(msg.id);
                  if (renderedIds.has(id)) return;
                  const outgoing = selfUserId && String(msg.senderId) === String(selfUserId);
                  const row = createMessageRow({ ...msg, bodyType: msg.bodyType || "text" }, { outgoing });
                  renderedIds.add(id);
                  messageNodes.set(id, row);
                  fragment.appendChild(row);
                });
                const container = messageListWrap || messageBody;
                const firstRow = container.querySelector(".message-row");
                if (firstRow) {
                  container.insertBefore(fragment, firstRow);
                } else {
                  container.appendChild(fragment);
                }
                const nextHeight = messageBody.scrollHeight;
                messageBody.scrollTop = prevTop + (nextHeight - prevHeight);
              }
              hasLoadedMessages = true;
              hasMoreMessages = data.hasMore === true;
              updateLoadMore();
            } else {
              updateMessages(data.messages, selfUserId || resolvedUserId || rawUserId);
              hasLoadedMessages = true;
              if (resetView) {
                hasMoreMessages = data.hasMore === true;
                updateLoadMore();
              }
            }
            writeMessageCache(conversationId);
          } catch (error) {
            if (error && error.name === "AbortError") return;
            if (!messageList.length) resetMessageView();
          } finally {
            if (requestToken === messageRequestToken) isLoadingMessages = false;
            if (shouldShowLoading) setMessagesLoading(false, { silent: isSilent });
            if (isDelta) setPollingIndicator(false);
            if (controller && messageFetchController === controller) {
              messageFetchController = null;
            }
          }
        };

        const scheduleMessagePoll = () => {
          if (isFile) return;
          if (messageTimer) {
            clearTimeout(messageTimer);
            messageTimer = null;
          }
          const interval = getMessagePollInterval();
          messageTimer = setTimeout(async () => {
            messageTimer = null;
            if (!activeConversationId) {
              scheduleMessagePoll();
              return;
            }
            if (isLoadingMessages) {
              scheduleMessagePoll();
              return;
            }
            await loadMessages(activeConversationId, { delta: true, silent: true });
            scheduleMessagePoll();
          }, interval);
        };

        const startMessagePolling = () => {
          if (isFile || !pollEnabled) return;
          if (!activeConversationId) return;
          scheduleMessagePoll();
        };

        const stopMessagePolling = () => {
          if (!messageTimer) return;
          clearTimeout(messageTimer);
          messageTimer = null;
          setPollingIndicator(false);
        };

        const finalizePendingMessage = (clientId, message, options = {}) => {
          const pending = pendingMessages.get(clientId);
          if (!pending || !pending.row) return;
          const row = pending.row;
          row.classList.remove("pending");
          row.classList.remove("failed");
          const status = row.querySelector(".message-status");
          if (status) {
            status.textContent = "Da gui";
            const statusNode = status;
            setTimeout(() => {
              if (statusNode && statusNode.parentElement && statusNode.textContent === "Da gui") {
                statusNode.remove();
              }
            }, 1200);
          }
          const retry = row.querySelector(".message-retry");
          if (retry) retry.remove();
          if (message && message.id) {
            row.dataset.messageId = String(message.id);
            messageNodes.set(String(message.id), row);
            renderedIds.add(String(message.id));
            messageMap.set(String(message.id), message);
            messageList = Array.from(messageMap.values()).sort((a, b) => parseTimestamp(a.createdAt) - parseTimestamp(b.createdAt));
            updateCursors();
          }
          if (message && message.createdAt) {
            const time = row.querySelector(".message-time");
            if (time) time.textContent = formatTimestamp(message.createdAt);
          }
          if (options.imageUrl) {
            const img = row.querySelector(".message-attachment img");
            if (img) {
              img.src = options.imageUrl;
              watchMediaLoad(img, { behavior: "auto", force: true });
            }
          }
          if (pending.previewUrl && options.revokePreview) {
            try {
              URL.revokeObjectURL(pending.previewUrl);
            } catch (error) {}
          }
          pendingMessages.delete(clientId);
        };

        const failPendingMessage = (clientId, statusText) => {
          const pending = pendingMessages.get(clientId);
          if (!pending || !pending.row) return;
          const row = pending.row;
          row.classList.remove("pending");
          row.classList.add("failed");
          const bubble = row.querySelector(".message-bubble");
          if (!bubble) return;
          let status = bubble.querySelector(".message-status");
          if (!status) {
            status = document.createElement("span");
            status.className = "message-status";
            bubble.appendChild(status);
          }
          status.textContent = statusText || "Gui that bai";
          let retry = bubble.querySelector(".message-retry");
          if (pending.file) {
            if (!retry) {
              retry = document.createElement("button");
              retry.type = "button";
              retry.className = "message-retry";
              retry.textContent = "Thu lai";
              retry.addEventListener("click", () => retryPendingImage(clientId));
              bubble.appendChild(retry);
            }
            retry.disabled = false;
          } else if (pending.body) {
            if (!retry) {
              retry = document.createElement("button");
              retry.type = "button";
              retry.className = "message-retry";
              retry.textContent = "Thu lai";
              retry.addEventListener("click", () => retryPendingText(clientId));
              bubble.appendChild(retry);
            }
            retry.disabled = false;
          } else if (retry) {
            retry.remove();
          }
        };

        const uploadImageMessage = async (clientId) => {
          const pending = pendingMessages.get(clientId);
          if (!pending || !pending.row || !pending.file) return false;
          if (isSendingImage) {
            notify("Dang gui anh, vui long doi.");
            return false;
          }
          const row = pending.row;
          row.classList.add("pending");
          row.classList.remove("failed");
          const bubble = row.querySelector(".message-bubble");
          if (bubble) {
            let status = bubble.querySelector(".message-status");
            if (!status) {
              status = document.createElement("span");
              status.className = "message-status";
              bubble.appendChild(status);
            }
            status.textContent = "Dang gui...";
            const retry = bubble.querySelector(".message-retry");
            if (retry) retry.disabled = true;
          }
          const targetUserId = pending.targetUserId;
          if (!targetUserId) {
            failPendingMessage(clientId, "Gui that bai");
            return false;
          }
          isSendingImage = true;
          setAttachLoading(true);
          let succeeded = false;
          try {
            let mediaUrl = pending.mediaUrl;
            let mediaId = pending.mediaId;
            if (!mediaUrl) {
              const form = new FormData();
              if (pending.isAdmin) {
                form.append("senderId", selfUserId || rawUserId);
                form.append("recipientId", targetUserId);
                form.append("asAdmin", "1");
              } else {
                form.append("userId", targetUserId);
              }
              if (pending.width) {
                form.append("width", String(pending.width));
              }
              if (pending.height) {
                form.append("height", String(pending.height));
              }
              form.append("file", pending.file);
              const uploadResponse = await fetch(uploadUrl, { method: "POST", body: form, cache: "no-store" });
              const uploadData = await uploadResponse.json().catch(() => null);
              if (!uploadResponse.ok || !uploadData || !uploadData.ok) {
                const errorCode = uploadData && uploadData.error ? String(uploadData.error) : "UPLOAD_FAILED";
                const hint = uploadData && uploadData.hint ? ` - ${uploadData.hint}` : "";
                const message = uploadData && uploadData.message ? ` - ${uploadData.message}` : "";
                throw new Error(`${errorCode}${hint}${message}`);
              }
              mediaUrl = uploadData.mediaUrl || (uploadData.media && uploadData.media.url) || "";
              mediaId = uploadData.mediaId || (uploadData.media && uploadData.media.id) || "";
              const uploadKey = uploadData.mediaKey || (uploadData.media && uploadData.media.key) || "";
              if (!mediaUrl) {
                throw new Error("UPLOAD_FAILED");
              }
              pending.mediaUrl = mediaUrl;
              pending.mediaId = mediaId;
              pending.mediaKey = uploadKey || pending.mediaKey || "";
            }
            const isDirect = pending.isDirect === true;
            const senderId = pending.senderId || selfUserId || rawUserId;
          const payload = pending.isAdmin
            ? {
                senderId,
                recipientId: targetUserId,
                body: mediaUrl,
                  bodyType: "image",
                  mediaUrl,
                  mediaId,
                  mediaKey: pending.mediaKey || undefined,
                  clientMessageId: pending.clientMessageId,
                  conversationId: pending.conversationId || undefined,
                }
              : isDirect
                ? {
                    userId: senderId,
                    recipientId: targetUserId,
                    body: mediaUrl,
                    bodyType: "image",
                    mediaUrl,
                    mediaId,
                    mediaKey: pending.mediaKey || undefined,
                    clientMessageId: pending.clientMessageId,
                    conversationId: pending.conversationId || undefined,
                  }
                : {
                    userId: targetUserId,
                    body: mediaUrl,
                    bodyType: "image",
                    mediaUrl,
                    mediaId,
                    mediaKey: pending.mediaKey || undefined,
                clientMessageId: pending.clientMessageId,
                conversationId: pending.conversationId || undefined,
              };
          const result = await sendMessageRequest(payload, pending.clientMessageId || clientId);
          if (result && result.aborted) {
            if (result.reason === "duplicate") return true;
            throw new Error("SEND_TIMEOUT");
          }
          const response = result && result.response ? result.response : null;
          const data = result && result.data ? result.data : null;
          if (!response || !response.ok || !data || !data.ok) {
            const errorCode = data && data.error ? String(data.error) : "SEND_FAILED";
            const hint = data && data.hint ? ` - ${data.hint}` : "";
            const message = data && data.message ? ` - ${data.message}` : "";
            throw new Error(`${errorCode}${hint}${message}`);
          }
          const meta = resolveSendMeta(data);
          const serverId = meta.messageId;
          if (!serverId) {
            throw new Error("SEND_FAILED");
          }
          const imageUrl = (meta.message && meta.message.body) || mediaUrl;
          finalizePendingMessage(
            clientId,
            {
              id: serverId,
              senderId: (meta.message && meta.message.senderId) || selfUserId,
              recipientId: (meta.message && meta.message.recipientId) || targetUserId,
              body: imageUrl,
              bodyType: (meta.message && (meta.message.bodyType || meta.message.type)) || "image",
              createdAt: meta.createdAt || pending.createdAt || new Date().toISOString(),
            },
            { imageUrl, revokePreview: true }
          );
          succeeded = true;
        } catch (error) {
          failPendingMessage(clientId, "Gui that bai");
          const reason = error && error.message === "SEND_TIMEOUT" ? "Het thoi gian gui anh." : "";
          notify(reason || (error && error.message ? error.message : "Khong the gui anh luc nay."));
        } finally {
          isSendingImage = false;
          setAttachLoading(false);
        }
          return succeeded;
        };

        const retryPendingImage = async (clientId) => {
          const pending = pendingMessages.get(clientId);
          if (!pending || !pending.file) return;
          markBoost();
          await uploadImageMessage(clientId);
        };

        const retryPendingText = async (clientId) => {
          const pending = pendingMessages.get(clientId);
          if (!pending || !pending.body) return;
          const row = pending.row;
          if (!row) return;
          const bubble = row.querySelector(".message-bubble");
          if (bubble) {
            let status = bubble.querySelector(".message-status");
            if (!status) {
              status = document.createElement("span");
              status.className = "message-status";
              bubble.appendChild(status);
            }
            status.textContent = "Dang gui...";
            const retry = bubble.querySelector(".message-retry");
            if (retry) retry.disabled = true;
          }
          const targetUserId = pending.targetUserId;
          if (!targetUserId) {
            failPendingMessage(clientId, "Gui that bai");
            return;
          }
          markBoost();
          const senderId = pending.senderId || selfUserId || rawUserId;
          const payload = pending.isAdmin
            ? {
                senderId,
                recipientId: targetUserId,
                body: pending.body,
                bodyType: "text",
                clientMessageId: pending.clientMessageId,
                conversationId: pending.conversationId || undefined,
              }
            : pending.isDirect
              ? {
                  userId: senderId,
                  recipientId: targetUserId,
                  body: pending.body,
                  bodyType: "text",
                  clientMessageId: pending.clientMessageId,
                  conversationId: pending.conversationId || undefined,
                }
              : {
                  userId: targetUserId,
                  body: pending.body,
                  bodyType: "text",
                  clientMessageId: pending.clientMessageId,
                  conversationId: pending.conversationId || undefined,
                };
          try {
            const result = await sendMessageRequest(payload, pending.clientMessageId || clientId);
            if (result && result.aborted) {
              if (result.reason === "duplicate") return;
              throw new Error("SEND_TIMEOUT");
            }
            const response = result && result.response ? result.response : null;
            const data = result && result.data ? result.data : null;
            if (!response || !response.ok || !data || !data.ok) {
              const errorCode = data && data.error ? String(data.error) : "SEND_FAILED";
              const hint = data && data.hint ? ` - ${data.hint}` : "";
              const message = data && data.message ? ` - ${data.message}` : "";
              throw new Error(`${errorCode}${hint}${message}`);
            }
            const meta = resolveSendMeta(data);
            const serverId = meta.messageId;
            if (!serverId) {
              throw new Error("SEND_FAILED");
            }
            const nextCreatedAt = meta.createdAt || pending.createdAt || new Date().toISOString();
            finalizePendingMessage(clientId, {
              id: serverId,
              senderId: (meta.message && meta.message.senderId) || senderId,
              recipientId: (meta.message && meta.message.recipientId) || targetUserId,
              body: (meta.message && meta.message.body) || pending.body,
              bodyType: (meta.message && (meta.message.bodyType || meta.message.type)) || "text",
              createdAt: nextCreatedAt,
            });
          } catch (error) {
            failPendingMessage(clientId, "Gui that bai");
            const reason = error && error.message === "SEND_TIMEOUT" ? "Het thoi gian gui tin." : "";
            notify(reason || (error && error.message ? error.message : "Khong the gui tin nhan luc nay."));
          }
        };

        const sendText = async () => {
          if (!messageInput) return;
          const text = messageInput.value.trim();
          if (!text) return;
          closeQuickReplies();
          if (!canSendMessage()) return;
          if (!auth || !auth.loggedIn) {
            if (window.BKAuth && typeof window.BKAuth.redirectToLogin === "function") {
              window.BKAuth.redirectToLogin();
            }
            return;
          }
          const isDirect = isDirectConversationId(activeConversationId);
          const senderId = selfUserId || rawUserId;
          const targetUserId = isAdminUser ? activeUserId : isDirect ? activeUserId : resolvedUserId || rawUserId;
          if (isAdminUser && !targetUserId) {
            notify("Chon cuoc tro chuyen de tra loi.");
            return;
          }
          if (!isAdminUser && isDirect && !targetUserId) {
            notify("Khong tim thay nguoi nhan.");
            return;
          }
          const createdAt = new Date().toISOString();
          if (!applySendDebounce()) return;
          if (isFile) {
            const row = createMessageRow({ body: text, bodyType: "text", createdAt }, { outgoing: true });
            if (messageListWrap) {
              messageListWrap.appendChild(row);
            } else {
              messageBody.appendChild(row);
            }
            watchMediaLoad(row, { behavior: "smooth", force: true });
            messageInput.value = "";
            messageInput.focus();
            return;
          }

          const conversationId = activeConversationId || "";
          const shouldStick = shouldStickToBottom || isNearBottom();
          const clientId = createClientId();
          const pendingRow = createMessageRow(
            { body: text, bodyType: "text", createdAt },
            { outgoing: true, pending: true, status: "Dang gui...", clientId }
          );
          pendingMessages.set(clientId, {
            row: pendingRow,
            body: text,
            bodyType: "text",
            senderId,
            targetUserId,
            conversationId,
            createdAt,
            isAdmin: isAdminUser,
            isDirect,
            clientMessageId: clientId,
          });
          if (messageListWrap) {
            messageListWrap.appendChild(pendingRow);
          } else {
            messageBody.appendChild(pendingRow);
          }
          if (shouldStick) watchMediaLoad(pendingRow, { behavior: "smooth", force: true });
          messageInput.value = "";
          messageInput.focus();
          markBoost();

          const payload = isAdminUser
            ? {
                senderId,
                recipientId: targetUserId,
                body: text,
                bodyType: "text",
                clientMessageId: clientId,
                conversationId: conversationId || undefined,
              }
            : isDirect
              ? {
                  userId: senderId,
                  recipientId: targetUserId,
                  body: text,
                  bodyType: "text",
                  clientMessageId: clientId,
                  conversationId: conversationId || undefined,
                }
              : {
                  userId: targetUserId,
                  body: text,
                  bodyType: "text",
                  clientMessageId: clientId,
                  conversationId: conversationId || undefined,
                };
          try {
            const result = await sendMessageRequest(payload, clientId);
            if (result && result.aborted) {
              if (result.reason === "duplicate") return;
              throw new Error("SEND_TIMEOUT");
            }
            const response = result && result.response ? result.response : null;
            const data = result && result.data ? result.data : null;
            if (!response || !response.ok || !data || !data.ok) {
              const errorCode = data && data.error ? String(data.error) : "SEND_FAILED";
              const hint = data && data.hint ? ` - ${data.hint}` : "";
              const message = data && data.message ? ` - ${data.message}` : "";
              throw new Error(`${errorCode}${hint}${message}`);
            }
            const meta = resolveSendMeta(data);
            const serverId = meta.messageId;
            if (!serverId) {
              throw new Error("SEND_FAILED");
            }
            const nextCreatedAt = meta.createdAt || createdAt;
            finalizePendingMessage(clientId, {
              id: serverId,
              senderId: (meta.message && meta.message.senderId) || selfUserId,
              recipientId: (meta.message && meta.message.recipientId) || targetUserId,
              body: (meta.message && meta.message.body) || text,
              bodyType: (meta.message && (meta.message.bodyType || meta.message.type)) || "text",
              createdAt: nextCreatedAt,
            });
          } catch (error) {
            failPendingMessage(clientId, "Gui that bai");
            const reason = error && error.message === "SEND_TIMEOUT" ? "Het thoi gian gui tin." : "";
            notify(reason || (error && error.message ? error.message : "Khong the gui tin nhan luc nay."));
          }
        };

        const setAttachLoading = (loading) => {
          if (attachBtn) attachBtn.disabled = loading;
          if (fileInput) fileInput.disabled = loading;
        };

        const readImageDimensions = async (file, previewUrl) => {
          if (!file) return null;
          if (typeof createImageBitmap === "function") {
            try {
              const bitmap = await createImageBitmap(file);
              const info = { width: bitmap.width, height: bitmap.height };
              if (typeof bitmap.close === "function") bitmap.close();
              return info;
            } catch (error) {}
          }
          return new Promise((resolve) => {
            const img = new Image();
            let tempUrl = "";
            if (previewUrl) {
              img.src = previewUrl;
            } else {
              try {
                tempUrl = URL.createObjectURL(file);
                img.src = tempUrl;
              } catch (error) {
                resolve(null);
                return;
              }
            }
            img.onload = () => {
              resolve({ width: img.naturalWidth || img.width, height: img.naturalHeight || img.height });
              if (tempUrl) {
                try {
                  URL.revokeObjectURL(tempUrl);
                } catch (error) {}
              }
            };
            img.onerror = () => {
              resolve(null);
              if (tempUrl) {
                try {
                  URL.revokeObjectURL(tempUrl);
                } catch (error) {}
              }
            };
          });
        };

        const syncSendButtonState = () => {
          if (!sendBtn) return;
          sendBtn.disabled = isComposerLocked || isSendDebounceActive;
        };
        const setChatInputDisabled = (disabled) => {
          isComposerLocked = disabled;
          if (messageInput) messageInput.disabled = disabled;
          if (attachBtn) attachBtn.disabled = disabled;
          if (emojiBtn) emojiBtn.disabled = disabled;
          if (fileInput) fileInput.disabled = disabled;
          syncSendButtonState();
        };
        const applySendDebounce = () => {
          if (isSendDebounceActive) return false;
          isSendDebounceActive = true;
          syncSendButtonState();
          if (sendDebounceTimer) clearTimeout(sendDebounceTimer);
          sendDebounceTimer = setTimeout(() => {
            isSendDebounceActive = false;
            syncSendButtonState();
          }, SEND_DEBOUNCE_MS);
          return true;
        };

        const setPreviewSending = (sending) => {
          isPreviewSending = sending;
          if (previewSend) {
            previewSend.disabled = sending;
            previewSend.classList.toggle("is-loading", sending);
            previewSend.textContent = sending ? "Dang gui..." : "Gui";
          }
          if (previewCancel) previewCancel.disabled = sending;
          if (previewClose) previewClose.disabled = sending;
        };

        const closeImagePreview = (options = {}) => {
          if (!isPreviewOpen) return;
          const preservePreview = options && options.preservePreview;
          if (previewModal) {
            previewModal.classList.remove("open");
            previewModal.setAttribute("aria-hidden", "true");
          }
          document.body.classList.remove("modal-open");
          setChatInputDisabled(false);
          isPreviewOpen = false;
          setPreviewSending(false);
          if (!preservePreview && pendingPreviewUrl) {
            try {
              URL.revokeObjectURL(pendingPreviewUrl);
            } catch (error) {}
          }
          pendingPreviewFile = null;
          pendingPreviewUrl = "";
          pendingPreviewClientId = "";
          if (previewImage) previewImage.src = "";
          if (previewSize) previewSize.textContent = "--";
        };

        const openImagePreview = (file) => {
          if (!file) return;
          if (isPreviewOpen) {
            notify("Dang xem anh, vui long gui hoac huy.");
            return;
          }
          if (!file.type || !file.type.startsWith("image/")) {
            notify(t("media.imageOnly", "Chi ho tro anh."));
            return;
          }
          if (file.size > MAX_IMAGE_SIZE) {
            notify(t("media.imageTooLarge", "Anh vuot qua 2MB."));
            return;
          }
          pendingPreviewFile = file;
          pendingPreviewClientId = createClientId();
          try {
            pendingPreviewUrl = URL.createObjectURL(file);
          } catch (error) {
            pendingPreviewUrl = "";
          }
          if (previewImage) previewImage.src = pendingPreviewUrl;
          if (previewSize) previewSize.textContent = formatFileSize(file.size);
          if (previewModal) {
            previewModal.classList.add("open");
            previewModal.setAttribute("aria-hidden", "false");
          }
          document.body.classList.add("modal-open");
          isPreviewOpen = true;
          setChatInputDisabled(true);
          setPreviewSending(false);
        };

        const confirmPreviewSend = async () => {
          if (isPreviewSending || !pendingPreviewFile) return;
          setPreviewSending(true);
          const result = await sendImage(pendingPreviewFile, {
            clientId: pendingPreviewClientId,
            previewUrl: pendingPreviewUrl || "",
          });
          if (result && result.ok) {
            closeImagePreview({ preservePreview: true });
          } else {
            setPreviewSending(false);
          }
        };

        const sendImage = async (file, options = {}) => {
          if (!file) return;
          closeQuickReplies();
          if (!canSendMessage()) return;
          const createdAt = new Date().toISOString();
          if (isFile) {
            const reader = new FileReader();
            reader.onload = (event) => {
              const src = event.target && event.target.result ? String(event.target.result) : "";
              const row = createMessageRow({ body: src, bodyType: "image", createdAt }, { outgoing: true });
              if (messageListWrap) {
                messageListWrap.appendChild(row);
              } else {
                messageBody.appendChild(row);
              }
              watchMediaLoad(row, { behavior: "smooth", force: true });
            };
            reader.readAsDataURL(file);
            return;
          }
          if (!auth || !auth.loggedIn) {
            if (window.BKAuth && typeof window.BKAuth.redirectToLogin === "function") {
              window.BKAuth.redirectToLogin();
            }
            return;
          }
          const isDirect = isDirectConversationId(activeConversationId);
          const senderId = selfUserId || rawUserId;
          const targetUserId = isAdminUser ? activeUserId : isDirect ? activeUserId : senderId;
          const conversationId = activeConversationId || "";
          if (isAdminUser && !targetUserId) {
            notify("Chon cuoc tro chuyen de gui anh.");
            return;
          }
          if (!isAdminUser && isDirect && !targetUserId) {
            notify("Khong tim thay nguoi nhan.");
            return;
          }
          if (isSendingImage) {
            notify("Dang gui anh, vui long doi.");
            return;
          }
          markBoost();

          const requestedClientId = options && options.clientId ? String(options.clientId) : "";
          if (requestedClientId && pendingMessages.has(requestedClientId)) {
            const ok = await uploadImageMessage(requestedClientId);
            return { ok, clientId: requestedClientId };
          }
          const clientId = requestedClientId || createClientId();
          let previewUrl = options && options.previewUrl ? String(options.previewUrl) : "";
          if (!previewUrl) {
            try {
              previewUrl = URL.createObjectURL(file);
            } catch (error) {}
          }
          let dimensions = null;
          try {
            dimensions = await readImageDimensions(file, previewUrl);
          } catch (error) {}
          const pendingRow = createMessageRow(
            { body: previewUrl, bodyType: "image", createdAt },
            { outgoing: true, pending: true, status: "Dang gui...", clientId }
          );
          pendingMessages.set(clientId, {
              row: pendingRow,
              previewUrl,
              bodyType: "image",
              file,
            targetUserId,
            conversationId,
            createdAt,
            isAdmin: isAdminUser,
            isDirect,
            senderId,
            clientMessageId: clientId,
              width: dimensions && dimensions.width ? dimensions.width : null,
              height: dimensions && dimensions.height ? dimensions.height : null,
              mediaUrl: "",
              mediaId: "",
            mediaKey: "",
          });
          const shouldStick = shouldStickToBottom || isNearBottom();
          if (messageListWrap) {
            messageListWrap.appendChild(pendingRow);
          } else {
            messageBody.appendChild(pendingRow);
          }
          if (shouldStick) watchMediaLoad(pendingRow, { behavior: "smooth", force: true });
          const ok = await uploadImageMessage(clientId);
          return { ok, clientId };
        };

        if (sendBtn) {
          sendBtn.addEventListener("click", sendText);
        }

        if (messageInput) {
          messageInput.addEventListener("keydown", (event) => {
            if (isQuickRepliesOpen()) {
              if (event.key === "ArrowDown") {
                event.preventDefault();
                moveQuickReply(1);
                return;
              }
              if (event.key === "ArrowUp") {
                event.preventDefault();
                moveQuickReply(-1);
                return;
              }
              if (event.key === "Enter") {
                event.preventDefault();
                const picked = quickReplyItems[quickReplyIndex];
                if (picked) applyQuickReply(picked);
                return;
              }
              if (event.key === "Escape") {
                closeQuickReplies();
                return;
              }
            }
            if (event.key === "Enter") {
              event.preventDefault();
              sendText();
            }
          });

          messageInput.addEventListener("input", () => {
            if (isAdminUser) updateQuickReplies();
            if (!document.hidden) markBoost();
          });
        }

        if (quickRepliesEl) {
          quickRepliesEl.addEventListener("click", (event) => {
            const btn = event.target.closest(".quick-reply-item");
            if (!btn) return;
            const index = Number(btn.dataset.index);
            const picked = quickReplyItems[index];
            if (picked) applyQuickReply(picked);
          });
        }

        const closeEmojiPanel = () => {
          if (emojiPanel) emojiPanel.classList.remove("open");
        };

        if (emojiBtn && emojiPanel) {
          emojiBtn.addEventListener("click", (event) => {
            event.stopPropagation();
            emojiPanel.classList.toggle("open");
          });
          emojiPanel.addEventListener("click", (event) => {
            const btn = event.target.closest("button[data-emoji]");
            if (!btn) return;
            const emoji = btn.getAttribute("data-emoji") || "";
            if (emoji) {
              messageInput.value += emoji;
              messageInput.focus();
            }
            closeEmojiPanel();
          });
          document.addEventListener("click", (event) => {
            if (event.target.closest("#emoji-panel") || event.target.closest("#message-emoji")) return;
            closeEmojiPanel();
          });
        }

        if (attachBtn && fileInput) {
          attachBtn.addEventListener("click", () => fileInput.click());
          fileInput.addEventListener("change", () => {
            const file = fileInput.files && fileInput.files[0];
            fileInput.value = "";
            if (!file) return;
            openImagePreview(file);
          });
        }

        const handlePreviewClose = () => {
          if (isPreviewSending) return;
          closeImagePreview();
        };

        if (previewSend) previewSend.addEventListener("click", confirmPreviewSend);
        if (previewCancel) previewCancel.addEventListener("click", handlePreviewClose);
        if (previewClose) previewClose.addEventListener("click", handlePreviewClose);
        if (previewModal) {
          previewModal.addEventListener("click", (event) => {
            if (event.target === previewModal) handlePreviewClose();
          });
        }
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape" && isPreviewOpen) {
            event.preventDefault();
            handlePreviewClose();
          }
        });

        window.ChatImagePreview = {
          open: openImagePreview,
          isOpen: () => isPreviewOpen,
          notify,
          maxSize: MAX_IMAGE_SIZE,
        };

        updateSearchUI();
        initChatLayoutSizing();
        const hasDeepLink = Boolean(initialConversationId || queryUserId || queryUsername);
        shouldAutoStartPolling = hasDeepLink;
        setConversationEmptyState(!hasDeepLink);

        if (inputWrap) inputWrap.style.display = "";
        const listPromise = loadConversationList();
        if (!isFile) {
          Promise.resolve(listPromise).finally(() => {
            schedulePollingStart();
          });
        }
        scrollToBottom({ behavior: "auto", force: false });
        } catch (error) {
          console.error("Chat init failed", error);
          const shell = document.getElementById("message-shell");
          if (shell) shell.classList.add("is-empty");
        }
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initMessagesPage);
      } else {
        initMessagesPage();
      }
    </script>
    <script type="module">
      import React, { useEffect } from "https://esm.sh/react@18.2.0";
      import { createRoot } from "https://esm.sh/react-dom@18.2.0/client";
      import { useDropzone } from "https://esm.sh/react-dropzone@14.2.3?deps=react@18.2.0";

      const initDropzone = () => {
        const portal = document.getElementById("chat-dropzone-portal");
        const target = document.getElementById("message-shell");
        const previewApi = window.ChatImagePreview;
        if (!portal || !target || !previewApi || typeof previewApi.open !== "function") return;

        const applyRootProps = (element, props) => {
          if (!element || !props) return () => {};
          const removers = [];
          Object.entries(props).forEach(([key, value]) => {
            if (key === "ref") {
              if (typeof value === "function") value(element);
              else if (value && typeof value === "object") value.current = element;
              return;
            }
            if (key === "tabIndex") {
              element.tabIndex = value;
              return;
            }
            if (key === "role" || key.startsWith("aria-")) {
              element.setAttribute(key, value);
              return;
            }
            if (!key.startsWith("on") || typeof value !== "function") return;
            const eventName = key.slice(2).toLowerCase();
            const handler = (event) => value(event);
            element.addEventListener(eventName, handler);
            removers.push(() => element.removeEventListener(eventName, handler));
          });
          return () => removers.forEach((remove) => remove());
        };

        const DropzoneBridge = () => {
          const maxSize = Number(previewApi.maxSize) || 2 * 1024 * 1024;
          const { getRootProps, getInputProps, isDragActive } = useDropzone({
            accept: { "image/*": [] },
            multiple: false,
            noClick: true,
            noKeyboard: true,
            maxSize,
            onDropAccepted: (files) => {
              const file = files && files[0];
              if (!file) return;
              if (previewApi.isOpen && previewApi.isOpen()) {
                if (typeof previewApi.notify === "function") {
                  previewApi.notify("Dang xem anh, vui long gui hoac huy.");
                }
                return;
              }
              previewApi.open(file);
            },
            onDropRejected: (rejections) => {
              if (!rejections || !rejections.length) return;
              const errors = rejections[0].errors || [];
              const hasSize = errors.some((err) => err.code === "file-too-large");
              const message = hasSize ? "Anh vuot qua 2MB." : "Chi ho tro anh.";
              if (typeof previewApi.notify === "function") previewApi.notify(message);
            },
          });

          useEffect(() => {
            const rootProps = getRootProps({ tabIndex: -1 });
            const handlePaste = (event) => {
              const files = event && event.clipboardData ? event.clipboardData.files : null;
              if (!files || !files.length) return;
              if (typeof rootProps.onDrop === "function") rootProps.onDrop(event);
            };
            const cleanup = applyRootProps(target, { ...rootProps, onPaste: handlePaste });
            return () => cleanup();
          }, [getRootProps]);

          useEffect(() => {
            target.classList.toggle("is-drop-active", isDragActive);
            return () => target.classList.remove("is-drop-active");
          }, [isDragActive]);

          const inputProps = getInputProps({ tabIndex: -1 });
          return React.createElement("input", { ...inputProps, style: { display: "none" } });
        };

        createRoot(portal).render(React.createElement(DropzoneBridge));
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initDropzone);
      } else {
        initDropzone();
      }
    </script>
  </body>
</html>




